OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T13:13:46.39045+01:00' ],		#prior : OmReference [ 'moose-6.1_bmdgwnk', '1141' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #SetValidator,				#isMetaSide : false			},			#name : #'validate:correctParser:',			#protocol : #'as yet unclassified',			#sourceCode : 'validate: aCollection correctParser: correctParser\r\t|parsedInputs correctlyParsedInputs finalResults|\r\t\r\t\r\tparsedInputs:=  ParserGenerator parseSet: aCollection.\r\tcorrectlyParsedInputs:= OrderedCollection new.\r\tfinalResults:= OrderedCollection new.\r\t\r\t\"get the correct parsed String\"\r\t(aCollection do: [ :string |\r\t\tcorrectlyParsedInputs add:(correctParser parse:string)\t ]).\r\t\r\r\t(1 to: parsedInputs size) do: [ :index |\r\t\t|visitor correctOutput allResults sortedResults|\r\t\t\tvisitor:= ExportVisitor new. \r\t\t\tsortedResults := SortedCollection sortBlock: [:c1 :c2 | c1 \t\t\tf1score >= c2 f1score].\r\t\t\tcorrectOutput:= (visitor visit: (correctlyParsedInputs at: \t\t\tindex)) output.\r\t\t\t\t\t\t\r\t\t\tallResults := (((ValidatorSuite new)\r\t\t\t\tcorrectResult: correctOutput;\r\t\t\t\tresults: (parsedInputs at: index);\r\t\t\t\tyourself) validate).\r\t\t\t\t\r\t\t\t\tallResults do: [ :result | (result isKindOf: ResultNode) & \t\t\t\t\t(result f1score isKindOf: Float)\r\t\t\t\t\tifTrue:[sortedResults add: result]].\r\t\t\t\t\r\t\t\t\tfinalResults add: (sortedResults at:1).\r\t\t\t\r\t\t ].\r\t^finalResults',			#stamp : 'Icewater 12/31/2016 11:48:14',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #SetValidator,				#isMetaSide : false			},			#name : #'validate:correctParser:',			#protocol : #'as yet unclassified',			#sourceCode : 'validate: aCollection correctParser: correctParser\r\t|parsedInputs correctlyParsedInputs finalResults|\r\t\r\tself halt.\r\tparsedInputs:=  ParserGenerator parseSet: aCollection.\r\tcorrectlyParsedInputs:= OrderedCollection new.\r\tfinalResults:= OrderedCollection new.\r\t\r\t\"get the correct parsed String\"\r\t(aCollection do: [ :string |\r\t\tcorrectlyParsedInputs add:(correctParser parse:string)\t ]).\r\t\r\r\t(1 to: parsedInputs size) do: [ :index |\r\t\t|visitor correctOutput allResults sortedResults|\r\t\t\tvisitor:= ExportVisitor new. \r\t\t\tsortedResults := SortedCollection sortBlock: [:c1 :c2 | c1 \t\t\tf1score >= c2 f1score].\r\t\t\tcorrectOutput:= (visitor visit: (correctlyParsedInputs at: \t\t\tindex)) output.\r\t\t\t\t\t\t\r\t\t\tallResults := (((ValidatorSuite new)\r\t\t\t\tcorrectResult: correctOutput;\r\t\t\t\tresults: (parsedInputs at: index);\r\t\t\t\tyourself) validate).\r\t\t\t\t\r\t\t\t\tallResults do: [ :result | (result isKindOf: ResultNode) & \t\t\t\t\t(result f1score isKindOf: Float)\r\t\t\t\t\tifTrue:[sortedResults add: result]].\r\t\t\t\t\r\t\t\t\tfinalResults add: (sortedResults at:1).\r\t\t\t\r\t\t ].\r\t^finalResults',			#stamp : 'MathiasFuchs 12/31/2016 13:13',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T13:21:49.79945+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '1' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSet:',			#protocol : #parsing,			#sourceCode : 'parseSet: aSet\t\r\t|parsers generators subResults results finalSubResults |\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\t\"not 100% sure about this, can be done better?\"\r\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t([ (parser parse:(aSet first)) isPetitFailure\t\t ] valueWithin: 300 milliSeconds onTimeout:(true)) ].\r\t\t\t\t\r\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t\t(res first isKindOf: Node) \r\t\t\t\t\t\t\t\tifTrue:[finalSubResults add: res first]]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results.',			#stamp : 'Icewater 12/31/2016 11:48:14',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSet:',			#protocol : #parsing,			#sourceCode : 'parseSet: aSet\t\r\t|parsers generators subResults results finalSubResults |\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tself halt.\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\t\"not 100% sure about this, can be done better?\"\r\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t([ (parser parse:(aSet first)) isPetitFailure\t\t ] valueWithin: 300 milliSeconds onTimeout:(true)) ].\r\t\t\t\t\r\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t\t(res first isKindOf: Node) \r\t\t\t\t\t\t\t\tifTrue:[finalSubResults add: res first]]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results.',			#stamp : 'MathiasFuchs 12/31/2016 13:21',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T13:27:12.98845+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '2' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSet:',			#protocol : #parsing,			#sourceCode : 'parseSet: aSet\t\r\t|parsers generators subResults results finalSubResults |\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tself halt.\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\t\"not 100% sure about this, can be done better?\"\r\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t([ (parser parse:(aSet first)) isPetitFailure\t\t ] valueWithin: 300 milliSeconds onTimeout:(true)) ].\r\t\t\t\t\r\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t\t(res first isKindOf: Node) \r\t\t\t\t\t\t\t\tifTrue:[finalSubResults add: res first]]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results.',			#stamp : 'MathiasFuchs 12/31/2016 13:21',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSet:',			#protocol : #parsing,			#sourceCode : 'parseSet: aSet\t\r\t|parsers generators subResults results finalSubResults |\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tself halt.\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\t\"not 100% sure about this, can be done better?\"\r\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t([ (parser parse:(aSet first)) isPetitFailure\t\t ] valueWithin: 300 milliSeconds onTimeout:(true)) ].\r\t\t\"need to remove more of the bad parsers\"\t\t\r\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t\t(res first isKindOf: Node) \r\t\t\t\t\t\t\t\tifTrue:[finalSubResults add: res first]]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results.',			#stamp : 'MathiasFuchs 12/31/2016 13:27',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T13:34:09.64945+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '3' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSet:',			#protocol : #parsing,			#sourceCode : 'parseSet: aSet\t\r\t|parsers generators subResults results finalSubResults |\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tself halt.\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\t\"not 100% sure about this, can be done better?\"\r\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t([ (parser parse:(aSet first)) isPetitFailure\t\t ] valueWithin: 300 milliSeconds onTimeout:(true)) ].\r\t\t\"need to remove more of the bad parsers\"\t\t\r\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t\t(res first isKindOf: Node) \r\t\t\t\t\t\t\t\tifTrue:[finalSubResults add: res first]]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results.',			#stamp : 'MathiasFuchs 12/31/2016 13:27',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSet:',			#protocol : #parsing,			#sourceCode : 'parseSet: aSet\t\r\t|parsers generators subResults results finalSubResults |\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\t\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\t\"not 100% sure about this, can be done better?\"\r\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t([ (parser parse:(aSet first)) isPetitFailure\t\t ] valueWithin: 300 milliSeconds onTimeout:(true)) ].\r\t\t\r\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t\t(res first isKindOf: Node) \r\t\t\t\t\t\t\t\tifTrue:[finalSubResults add: res first]]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results.',			#stamp : 'MathiasFuchs 12/31/2016 13:34',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T13:34:14.87845+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '4' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults |\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\t\"not 100% sure about this, can be done better?\"\r\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t([ (parser parse:(aSet first)) isPetitFailure\t\t ] valueWithin: 300 milliSeconds onTimeout:(true)) ].\r\t\t\t\t\r\t\"try to order, have to redo this, absolutely. This is broken ugly :S \"\t\t\r\tparsers:= (parsers sorted: [ :eltA :eltB | \r\t\t|a b|\r\t\t\r\t\ta:= (eltA parse: aSet first).\r\t\tb:= (eltB parse: (aSet first)).\r\t\t\r\t\t(a isKindOf:Collection)\r\t\tifTrue:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: a;\r\t\t\tyourself]\r\t\tifFalse:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: a;\r\t\t\tyourself].\r\t\t\r\t\t(b isKindOf:Collection)\r\t\tifTrue:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: b;\r\t\t\tyourself]\r\t\tifFalse:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: b;\r\t\t\tyourself].\r\t\t\r\t\t a allChildrenWeight > b\tallChildrenWeight ] ).\r\t\r\tparsers:= parsers first:60.\r\t\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'Icewater 12/31/2016 11:48:14',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults |\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\t\tself halt.\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\t\"not 100% sure about this, can be done better?\"\r\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t([ (parser parse:(aSet first)) isPetitFailure\t\t ] valueWithin: 300 milliSeconds onTimeout:(true)) ].\r\t\t\t\t\r\t\"try to order, have to redo this, absolutely. This is broken ugly :S \"\t\t\r\tparsers:= (parsers sorted: [ :eltA :eltB | \r\t\t|a b|\r\t\t\r\t\ta:= (eltA parse: aSet first).\r\t\tb:= (eltB parse: (aSet first)).\r\t\t\r\t\t(a isKindOf:Collection)\r\t\tifTrue:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: a;\r\t\t\tyourself]\r\t\tifFalse:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: a;\r\t\t\tyourself].\r\t\t\r\t\t(b isKindOf:Collection)\r\t\tifTrue:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: b;\r\t\t\tyourself]\r\t\tifFalse:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: b;\r\t\t\tyourself].\r\t\t\r\t\t a allChildrenWeight > b\tallChildrenWeight ] ).\r\t\r\tparsers:= parsers first:60.\r\t\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 13:34',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T13:35:00.33145+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '5' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults |\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\t\tself halt.\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\t\"not 100% sure about this, can be done better?\"\r\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t([ (parser parse:(aSet first)) isPetitFailure\t\t ] valueWithin: 300 milliSeconds onTimeout:(true)) ].\r\t\t\t\t\r\t\"try to order, have to redo this, absolutely. This is broken ugly :S \"\t\t\r\tparsers:= (parsers sorted: [ :eltA :eltB | \r\t\t|a b|\r\t\t\r\t\ta:= (eltA parse: aSet first).\r\t\tb:= (eltB parse: (aSet first)).\r\t\t\r\t\t(a isKindOf:Collection)\r\t\tifTrue:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: a;\r\t\t\tyourself]\r\t\tifFalse:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: a;\r\t\t\tyourself].\r\t\t\r\t\t(b isKindOf:Collection)\r\t\tifTrue:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: b;\r\t\t\tyourself]\r\t\tifFalse:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: b;\r\t\t\tyourself].\r\t\t\r\t\t a allChildrenWeight > b\tallChildrenWeight ] ).\r\t\r\tparsers:= parsers first:60.\r\t\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 13:34',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults |\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\t\tself halt.\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\t\"not 100% sure about this, can be done better?\"\r\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t([ (parser parse:(aSet first)) isPetitFailure\t\t ] valueWithin: 300 milliSeconds onTimeout:(true)) ].\r\t\t\t\t\r\t\"try to order, have to redo this, absolutely. This is broken ugly :S \"\t\t\r\tparsers:= (parsers sorted: [ :eltA :eltB | \r\t\t|a b|\r\t\t\r\t\ta:= (eltA parse: aSet first).\r\t\tb:= (eltB parse: (aSet first)).\r\t\t\r\t\t(a isKindOf:Collection)\r\t\tifTrue:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: a;\r\t\t\tyourself]\r\t\tifFalse:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: a;\r\t\t\tyourself].\r\t\t\r\t\t(b isKindOf:Collection)\r\t\tifTrue:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: b;\r\t\t\tyourself]\r\t\tifFalse:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: b;\r\t\t\tyourself].\r\t\t\r\t\t (eltA allChildrenWeight > eltB allChildrenWeight) & (eltA allChildrenSeas < eltB allChildrenSeas) ] ).\r\t\r\tparsers:= parsers first:60.\r\t\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 13:35',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T13:36:08.51845+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '6' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults |\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\t\tself halt.\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\t\"not 100% sure about this, can be done better?\"\r\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t([ (parser parse:(aSet first)) isPetitFailure\t\t ] valueWithin: 300 milliSeconds onTimeout:(true)) ].\r\t\t\t\t\r\t\"try to order, have to redo this, absolutely. This is broken ugly :S \"\t\t\r\tparsers:= (parsers sorted: [ :eltA :eltB | \r\t\t|a b|\r\t\t\r\t\ta:= (eltA parse: aSet first).\r\t\tb:= (eltB parse: (aSet first)).\r\t\t\r\t\t(a isKindOf:Collection)\r\t\tifTrue:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: a;\r\t\t\tyourself]\r\t\tifFalse:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: a;\r\t\t\tyourself].\r\t\t\r\t\t(b isKindOf:Collection)\r\t\tifTrue:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: b;\r\t\t\tyourself]\r\t\tifFalse:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: b;\r\t\t\tyourself].\r\t\t\r\t\t (eltA allChildrenWeight > eltB allChildrenWeight) & (eltA allChildrenSeas < eltB allChildrenSeas) ] ).\r\t\r\tparsers:= parsers first:60.\r\t\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 13:35',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults |\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\t\tself halt.\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\t\"not 100% sure about this, can be done better?\"\r\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t([ (parser parse:(aSet first)) isPetitFailure\t\t ] valueWithin: 300 milliSeconds onTimeout:(true)) ].\r\t\t\t\t\r\t\"try to order, have to redo this, absolutely. This is broken ugly :S \"\t\t\r\tparsers:= (parsers sorted: [ :eltA :eltB | \r\t\t|a b|\r\t\t\r\t\ta:= (eltA parse: (aSet first)).\r\t\tb:= (eltB parse: (aSet first)).\r\t\t\r\t\t(a isKindOf:Collection)\r\t\tifTrue:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: a;\r\t\t\tyourself]\r\t\tifFalse:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: a;\r\t\t\tyourself].\r\t\t\r\t\t(b isKindOf:Collection)\r\t\tifTrue:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: b;\r\t\t\tyourself]\r\t\tifFalse:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: b;\r\t\t\tyourself].\r\t\t\r\t\t (eltA allChildrenWeight > eltB allChildrenWeight) & (eltA allChildrenSeas < eltB allChildrenSeas) ] ).\r\t\r\tparsers:= parsers first:60.\r\t\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 13:36',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T13:36:15.07745+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '7' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #SetValidator,				#isMetaSide : false			},			#name : #'validate:correctParser:',			#protocol : #'as yet unclassified',			#sourceCode : 'validate: aCollection correctParser: correctParser\r\t|parsedInputs correctlyParsedInputs finalResults|\r\t\r\tself halt.\r\tparsedInputs:=  ParserGenerator parseSet: aCollection.\r\tcorrectlyParsedInputs:= OrderedCollection new.\r\tfinalResults:= OrderedCollection new.\r\t\r\t\"get the correct parsed String\"\r\t(aCollection do: [ :string |\r\t\tcorrectlyParsedInputs add:(correctParser parse:string)\t ]).\r\t\r\r\t(1 to: parsedInputs size) do: [ :index |\r\t\t|visitor correctOutput allResults sortedResults|\r\t\t\tvisitor:= ExportVisitor new. \r\t\t\tsortedResults := SortedCollection sortBlock: [:c1 :c2 | c1 \t\t\tf1score >= c2 f1score].\r\t\t\tcorrectOutput:= (visitor visit: (correctlyParsedInputs at: \t\t\tindex)) output.\r\t\t\t\t\t\t\r\t\t\tallResults := (((ValidatorSuite new)\r\t\t\t\tcorrectResult: correctOutput;\r\t\t\t\tresults: (parsedInputs at: index);\r\t\t\t\tyourself) validate).\r\t\t\t\t\r\t\t\t\tallResults do: [ :result | (result isKindOf: ResultNode) & \t\t\t\t\t(result f1score isKindOf: Float)\r\t\t\t\t\tifTrue:[sortedResults add: result]].\r\t\t\t\t\r\t\t\t\tfinalResults add: (sortedResults at:1).\r\t\t\t\r\t\t ].\r\t^finalResults',			#stamp : 'MathiasFuchs 12/31/2016 13:13',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #SetValidator,				#isMetaSide : false			},			#name : #'validate:correctParser:',			#protocol : #'as yet unclassified',			#sourceCode : 'validate: aCollection correctParser: correctParser\r\t|parsedInputs correctlyParsedInputs finalResults|\r\t\r\tself halt.\r\tparsedInputs:=  ParserGenerator parseSetWithOrder: aCollection.\r\tcorrectlyParsedInputs:= OrderedCollection new.\r\tfinalResults:= OrderedCollection new.\r\t\r\t\"get the correct parsed String\"\r\t(aCollection do: [ :string |\r\t\tcorrectlyParsedInputs add:(correctParser parse:string)\t ]).\r\t\r\r\t(1 to: parsedInputs size) do: [ :index |\r\t\t|visitor correctOutput allResults sortedResults|\r\t\t\tvisitor:= ExportVisitor new. \r\t\t\tsortedResults := SortedCollection sortBlock: [:c1 :c2 | c1 \t\t\tf1score >= c2 f1score].\r\t\t\tcorrectOutput:= (visitor visit: (correctlyParsedInputs at: \t\t\tindex)) output.\r\t\t\t\t\t\t\r\t\t\tallResults := (((ValidatorSuite new)\r\t\t\t\tcorrectResult: correctOutput;\r\t\t\t\tresults: (parsedInputs at: index);\r\t\t\t\tyourself) validate).\r\t\t\t\t\r\t\t\t\tallResults do: [ :result | (result isKindOf: ResultNode) & \t\t\t\t\t(result f1score isKindOf: Float)\r\t\t\t\t\tifTrue:[sortedResults add: result]].\r\t\t\t\t\r\t\t\t\tfinalResults add: (sortedResults at:1).\r\t\t\t\r\t\t ].\r\t^finalResults',			#stamp : 'MathiasFuchs 12/31/2016 13:36',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T13:38:17.97045+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '8' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults |\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\t\tself halt.\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\t\"not 100% sure about this, can be done better?\"\r\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t([ (parser parse:(aSet first)) isPetitFailure\t\t ] valueWithin: 300 milliSeconds onTimeout:(true)) ].\r\t\t\t\t\r\t\"try to order, have to redo this, absolutely. This is broken ugly :S \"\t\t\r\tparsers:= (parsers sorted: [ :eltA :eltB | \r\t\t|a b|\r\t\t\r\t\ta:= (eltA parse: (aSet first)).\r\t\tb:= (eltB parse: (aSet first)).\r\t\t\r\t\t(a isKindOf:Collection)\r\t\tifTrue:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: a;\r\t\t\tyourself]\r\t\tifFalse:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: a;\r\t\t\tyourself].\r\t\t\r\t\t(b isKindOf:Collection)\r\t\tifTrue:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: b;\r\t\t\tyourself]\r\t\tifFalse:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: b;\r\t\t\tyourself].\r\t\t\r\t\t (eltA allChildrenWeight > eltB allChildrenWeight) & (eltA allChildrenSeas < eltB allChildrenSeas) ] ).\r\t\r\tparsers:= parsers first:60.\r\t\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 13:36',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults |\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\t\tself halt.\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\t\"not 100% sure about this, can be done better?\"\r\t\"First item has to be short, else this will propbably not work, add assertion for it?\"\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t([ (parser parse:(aSet first)) isPetitFailure\t\t ] valueWithin: 100 milliSeconds onTimeout:(true)) ].\r\t\t\t\t\r\t\"try to order, have to redo this, absolutely. This is broken ugly :S \"\t\t\r\tparsers:= (parsers sorted: [ :eltA :eltB | \r\t\t|a b|\r\t\t\r\t\ta:= (eltA parse: (aSet first)).\r\t\tb:= (eltB parse: (aSet first)).\r\t\t\r\t\t(a isKindOf:Collection)\r\t\tifTrue:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: a;\r\t\t\tyourself]\r\t\tifFalse:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: a;\r\t\t\tyourself].\r\t\t\r\t\t(b isKindOf:Collection)\r\t\tifTrue:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: b;\r\t\t\tyourself]\r\t\tifFalse:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: b;\r\t\t\tyourself].\r\t\t\r\t\t (eltA allChildrenWeight > eltB allChildrenWeight) & (eltA allChildrenSeas < eltB allChildrenSeas) ] ).\r\t\r\tparsers:= parsers first:60.\r\t\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 13:38',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T13:38:59.13145+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '9' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults |\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\t\tself halt.\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\t\"not 100% sure about this, can be done better?\"\r\t\"First item has to be short, else this will propbably not work, add assertion for it?\"\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t([ (parser parse:(aSet first)) isPetitFailure\t\t ] valueWithin: 100 milliSeconds onTimeout:(true)) ].\r\t\t\t\t\r\t\"try to order, have to redo this, absolutely. This is broken ugly :S \"\t\t\r\tparsers:= (parsers sorted: [ :eltA :eltB | \r\t\t|a b|\r\t\t\r\t\ta:= (eltA parse: (aSet first)).\r\t\tb:= (eltB parse: (aSet first)).\r\t\t\r\t\t(a isKindOf:Collection)\r\t\tifTrue:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: a;\r\t\t\tyourself]\r\t\tifFalse:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: a;\r\t\t\tyourself].\r\t\t\r\t\t(b isKindOf:Collection)\r\t\tifTrue:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: b;\r\t\t\tyourself]\r\t\tifFalse:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: b;\r\t\t\tyourself].\r\t\t\r\t\t (eltA allChildrenWeight > eltB allChildrenWeight) & (eltA allChildrenSeas < eltB allChildrenSeas) ] ).\r\t\r\tparsers:= parsers first:60.\r\t\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 13:38',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults |\r\t\"assertion to make sure set is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\t\tself halt.\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\t\"not 100% sure about this, can be done better?\"\r\t\"First item has to be short, else this will propbably not work, add assertion for it?\"\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t([ (parser parse:(aSet first)) isPetitFailure\t\t ] valueWithin: 100 milliSeconds onTimeout:(true)) ].\r\t\t\t\t\r\t\"try to order, have to redo this, absolutely. This is broken ugly :S \"\t\t\r\tparsers:= (parsers sorted: [ :eltA :eltB | \r\t\t|a b|\r\t\t\r\t\ta:= (eltA parse: (aSet first)).\r\t\tb:= (eltB parse: (aSet first)).\r\t\t\r\t\t(a isKindOf:Collection)\r\t\tifTrue:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: a;\r\t\t\tyourself]\r\t\tifFalse:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: a;\r\t\t\tyourself].\r\t\t\r\t\t(b isKindOf:Collection)\r\t\tifTrue:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: b;\r\t\t\tyourself]\r\t\tifFalse:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: b;\r\t\t\tyourself].\r\t\t\r\t\t (eltA allChildrenWeight > eltB allChildrenWeight) & (eltA allChildrenSeas < eltB allChildrenSeas) ] ).\r\t\r\tparsers:= parsers first:60.\r\t\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 13:38',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T13:39:02.97745+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '10' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults |\r\t\"assertion to make sure set is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\t\tself halt.\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\t\"not 100% sure about this, can be done better?\"\r\t\"First item has to be short, else this will propbably not work, add assertion for it?\"\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t([ (parser parse:(aSet first)) isPetitFailure\t\t ] valueWithin: 100 milliSeconds onTimeout:(true)) ].\r\t\t\t\t\r\t\"try to order, have to redo this, absolutely. This is broken ugly :S \"\t\t\r\tparsers:= (parsers sorted: [ :eltA :eltB | \r\t\t|a b|\r\t\t\r\t\ta:= (eltA parse: (aSet first)).\r\t\tb:= (eltB parse: (aSet first)).\r\t\t\r\t\t(a isKindOf:Collection)\r\t\tifTrue:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: a;\r\t\t\tyourself]\r\t\tifFalse:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: a;\r\t\t\tyourself].\r\t\t\r\t\t(b isKindOf:Collection)\r\t\tifTrue:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: b;\r\t\t\tyourself]\r\t\tifFalse:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: b;\r\t\t\tyourself].\r\t\t\r\t\t (eltA allChildrenWeight > eltB allChildrenWeight) & (eltA allChildrenSeas < eltB allChildrenSeas) ] ).\r\t\r\tparsers:= parsers first:60.\r\t\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 13:38',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults |\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\t\tself halt.\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\t\"not 100% sure about this, can be done better?\"\r\t\"First item has to be short, else this will propbably not work, add assertion for it?\"\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t([ (parser parse:(aSet first)) isPetitFailure\t\t ] valueWithin: 100 milliSeconds onTimeout:(true)) ].\r\t\t\t\t\r\t\"try to order, have to redo this, absolutely. This is broken ugly :S \"\t\t\r\tparsers:= (parsers sorted: [ :eltA :eltB | \r\t\t|a b|\r\t\t\r\t\ta:= (eltA parse: (aSet first)).\r\t\tb:= (eltB parse: (aSet first)).\r\t\t\r\t\t(a isKindOf:Collection)\r\t\tifTrue:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: a;\r\t\t\tyourself]\r\t\tifFalse:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: a;\r\t\t\tyourself].\r\t\t\r\t\t(b isKindOf:Collection)\r\t\tifTrue:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: b;\r\t\t\tyourself]\r\t\tifFalse:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: b;\r\t\t\tyourself].\r\t\t\r\t\t (eltA allChildrenWeight > eltB allChildrenWeight) & (eltA allChildrenSeas < eltB allChildrenSeas) ] ).\r\t\r\tparsers:= parsers first:60.\r\t\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 13:39',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T13:45:22.61945+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '11' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults |\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\t\tself halt.\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\t\"not 100% sure about this, can be done better?\"\r\t\"First item has to be short, else this will propbably not work, add assertion for it?\"\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t([ (parser parse:(aSet first)) isPetitFailure\t\t ] valueWithin: 100 milliSeconds onTimeout:(true)) ].\r\t\t\t\t\r\t\"try to order, have to redo this, absolutely. This is broken ugly :S \"\t\t\r\tparsers:= (parsers sorted: [ :eltA :eltB | \r\t\t|a b|\r\t\t\r\t\ta:= (eltA parse: (aSet first)).\r\t\tb:= (eltB parse: (aSet first)).\r\t\t\r\t\t(a isKindOf:Collection)\r\t\tifTrue:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: a;\r\t\t\tyourself]\r\t\tifFalse:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: a;\r\t\t\tyourself].\r\t\t\r\t\t(b isKindOf:Collection)\r\t\tifTrue:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: b;\r\t\t\tyourself]\r\t\tifFalse:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: b;\r\t\t\tyourself].\r\t\t\r\t\t (eltA allChildrenWeight > eltB allChildrenWeight) & (eltA allChildrenSeas < eltB allChildrenSeas) ] ).\r\t\r\tparsers:= parsers first:60.\r\t\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 13:39',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults |\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\t\"not 100% sure about this, can be done better?\"\r\t\"First item has to be short, else this will propbably not work, add assertion for it?\"\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t([ (parser parse:(aSet first)) isPetitFailure\t\t ] valueWithin: 100 milliSeconds onTimeout:(true)) ].\r\t\t\t\t\r\t\"try to order, have to redo this, absolutely. This is broken ugly :S \"\t\t\r\tparsers:= (parsers sorted: [ :eltA :eltB | \r\t\t|a b|\r\t\t\r\t\ta:= (eltA parse: (aSet first)).\r\t\tb:= (eltB parse: (aSet first)).\r\t\t\r\t\t(a isKindOf:Collection)\r\t\tifTrue:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: a;\r\t\t\tyourself]\r\t\tifFalse:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: a;\r\t\t\tyourself].\r\t\t\r\t\t(b isKindOf:Collection)\r\t\tifTrue:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: b;\r\t\t\tyourself]\r\t\tifFalse:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: b;\r\t\t\tyourself].\r\t\t\r\t\t (eltA allChildrenWeight > eltB allChildrenWeight) & (eltA allChildrenSeas < eltB allChildrenSeas) ] ).\r\t\r\tparsers:= parsers first:60.\r\t\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 13:45',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T13:45:28.20945+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '12' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults |\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\t\"not 100% sure about this, can be done better?\"\r\t\"First item has to be short, else this will propbably not work, add assertion for it?\"\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t([ (parser parse:(aSet first)) isPetitFailure\t\t ] valueWithin: 100 milliSeconds onTimeout:(true)) ].\r\t\t\t\t\r\t\"try to order, have to redo this, absolutely. This is broken ugly :S \"\t\t\r\tparsers:= (parsers sorted: [ :eltA :eltB | \r\t\t|a b|\r\t\t\r\t\ta:= (eltA parse: (aSet first)).\r\t\tb:= (eltB parse: (aSet first)).\r\t\t\r\t\t(a isKindOf:Collection)\r\t\tifTrue:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: a;\r\t\t\tyourself]\r\t\tifFalse:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: a;\r\t\t\tyourself].\r\t\t\r\t\t(b isKindOf:Collection)\r\t\tifTrue:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: b;\r\t\t\tyourself]\r\t\tifFalse:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: b;\r\t\t\tyourself].\r\t\t\r\t\t (eltA allChildrenWeight > eltB allChildrenWeight) & (eltA allChildrenSeas < eltB allChildrenSeas) ] ).\r\t\r\tparsers:= parsers first:60.\r\t\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 13:45',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults |\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\t\"not 100% sure about this, can be done better?\"\r\t\"First item has to be short, else this will propbably not work, add assertion for it?\"\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t([ (parser parse:(aSet first)) isPetitFailure\t\t ] valueWithin: 100 milliSeconds onTimeout:(true)) ].\r\t\t\t\t\r\t\"try to order, have to redo this, absolutely. This is broken ugly :S \"\t\t\r\tparsers:= (parsers sorted: [ :eltA :eltB | \r\t\t|a b|\r\t\t\r\t\ta:= (eltA parse: (aSet first)).\r\t\tb:= (eltB parse: (aSet first)).\r\t\tself halt.\r\t\t(a isKindOf:Collection)\r\t\tifTrue:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: a;\r\t\t\tyourself]\r\t\tifFalse:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: a;\r\t\t\tyourself].\r\t\t\r\t\t(b isKindOf:Collection)\r\t\tifTrue:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: b;\r\t\t\tyourself]\r\t\tifFalse:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: b;\r\t\t\tyourself].\r\t\t\r\t\t (eltA allChildrenWeight > eltB allChildrenWeight) & (eltA allChildrenSeas < eltB allChildrenSeas) ] ).\r\t\r\tparsers:= parsers first:60.\r\t\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 13:45',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T13:47:12.42745+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '13' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults |\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\t\"not 100% sure about this, can be done better?\"\r\t\"First item has to be short, else this will propbably not work, add assertion for it?\"\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t([ (parser parse:(aSet first)) isPetitFailure\t\t ] valueWithin: 100 milliSeconds onTimeout:(true)) ].\r\t\t\t\t\r\t\"try to order, have to redo this, absolutely. This is broken ugly :S \"\t\t\r\tparsers:= (parsers sorted: [ :eltA :eltB | \r\t\t|a b|\r\t\t\r\t\ta:= (eltA parse: (aSet first)).\r\t\tb:= (eltB parse: (aSet first)).\r\t\tself halt.\r\t\t(a isKindOf:Collection)\r\t\tifTrue:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: a;\r\t\t\tyourself]\r\t\tifFalse:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: a;\r\t\t\tyourself].\r\t\t\r\t\t(b isKindOf:Collection)\r\t\tifTrue:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: b;\r\t\t\tyourself]\r\t\tifFalse:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: b;\r\t\t\tyourself].\r\t\t\r\t\t (eltA allChildrenWeight > eltB allChildrenWeight) & (eltA allChildrenSeas < eltB allChildrenSeas) ] ).\r\t\r\tparsers:= parsers first:60.\r\t\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 13:45',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults |\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\t\"not 100% sure about this, can be done better?\"\r\t\"First item has to be short, else this will propbably not work, add assertion for it?\"\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t([ (parser parse:(aSet first)) isPetitFailure\t\t ] valueWithin: 100 milliSeconds onTimeout:(true)) ].\r\t\t\t\t\r\t\"try to order, have to redo this, absolutely. This is broken ugly :S \"\t\t\r\tparsers:= (parsers sorted: [ :eltA :eltB | \r\t\t|a b|\r\t\t\r\t\ta:= (eltA parse: (aSet first)).\r\t\tb:= (eltB parse: (aSet first)).\r\t\tself halt.\r\t\t(a isKindOf:Collection)\r\t\tifTrue:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: a;\r\t\t\tyourself]\r\t\tifFalse:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: a;\r\t\t\tyourself].\r\t\t\r\t\t(b isKindOf:Collection)\r\t\tifTrue:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: b;\r\t\t\tyourself]\r\t\tifFalse:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: b;\r\t\t\tyourself].\r\t\t\r\t\t (a allChildrenWeight > b allChildrenWeight) & (a allChildrenSeas < b allChildrenSeas) ] ).\r\t\r\tparsers:= parsers first:60.\r\t\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 13:47',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T13:47:27.61545+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '14' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults |\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\t\"not 100% sure about this, can be done better?\"\r\t\"First item has to be short, else this will propbably not work, add assertion for it?\"\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t([ (parser parse:(aSet first)) isPetitFailure\t\t ] valueWithin: 100 milliSeconds onTimeout:(true)) ].\r\t\t\t\t\r\t\"try to order, have to redo this, absolutely. This is broken ugly :S \"\t\t\r\tparsers:= (parsers sorted: [ :eltA :eltB | \r\t\t|a b|\r\t\t\r\t\ta:= (eltA parse: (aSet first)).\r\t\tb:= (eltB parse: (aSet first)).\r\t\tself halt.\r\t\t(a isKindOf:Collection)\r\t\tifTrue:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: a;\r\t\t\tyourself]\r\t\tifFalse:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: a;\r\t\t\tyourself].\r\t\t\r\t\t(b isKindOf:Collection)\r\t\tifTrue:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: b;\r\t\t\tyourself]\r\t\tifFalse:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: b;\r\t\t\tyourself].\r\t\t\r\t\t (a allChildrenWeight > b allChildrenWeight) & (a allChildrenSeas < b allChildrenSeas) ] ).\r\t\r\tparsers:= parsers first:60.\r\t\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 13:47',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults |\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\t\"not 100% sure about this, can be done better?\"\r\t\"First item has to be short, else this will propbably not work, add assertion for it?\"\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t([ (parser parse:(aSet first)) isPetitFailure\t\t ] valueWithin: 100 milliSeconds onTimeout:(true)) ].\r\t\t\t\t\r\t\"try to order, have to redo this, absolutely. This is broken ugly :S \"\t\t\r\tparsers:= (parsers sorted: [ :eltA :eltB | \r\t\t|a b|\r\t\t\r\t\ta:= (eltA parse: (aSet first)).\r\t\tb:= (eltB parse: (aSet first)).\r\t\t\r\t\t(a isKindOf:Collection)\r\t\tifTrue:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: a;\r\t\t\tyourself]\r\t\tifFalse:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: a;\r\t\t\tyourself].\r\t\t\r\t\t(b isKindOf:Collection)\r\t\tifTrue:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: b;\r\t\t\tyourself]\r\t\tifFalse:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: b;\r\t\t\tyourself].\r\t\t\r\t\t (a allChildrenWeight > b allChildrenWeight) & (a allChildrenSeas < b allChildrenSeas) ] ).\r\t\r\tparsers:= parsers first:60.\r\tself halt.\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 13:47',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T13:56:56.97145+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '15' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #BruteForceParserGeneratorTest,				#isMetaSide : false			},			#name : #testParseWithOrder,			#protocol : #tests,			#sourceCode : 'testParseWithOrder\r\t|string result |\r\tstring:= \'<a>\r\t<b>c</b>\r</a>\'.\r\tresult:= ParserGenerator parseWithOrder: string.\r\t\r\tself assert: (result isKindOf: OrderedCollection).\r\tself assert: (result anySatisfy: [ :e | e isKindOf: Node ]).\r\tself assert: (result anySatisfy: [ :e | e name = \'a\']).\r\tself assert: (result anySatisfy: [ :e | (e isKindOf: Node) \r\t\tifTrue:[ e children isEmpty \r\t\t\tifTrue:[false] \r\t\t\tifFalse:[e children first name= \'b\']]\r\t\tifFalse:[false]\r\t\t]).\r\tself assert: (result at:1) allChildrenWeight = 26.2.\r\tself assert: (result at:1) name equals:\'a\'.\r\tself assert:(result at:1) children first name equals:\'b\'.\r\tself assert:(result at:1) children first children first contents equals:\'c\'.\r',			#stamp : 'Icewater 12/31/2016 11:48:14',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #BruteForceParserGeneratorTest,				#isMetaSide : false			},			#name : #testParseWithOrder,			#protocol : #tests,			#sourceCode : 'testParseWithOrder\r\t|string result |\r\tstring:= \'<a>\r\t<b>c</b>\r</a>\'.\r\tresult:= ParserGenerator parseWithOrder: string.\r\t\r\tself assert: (result isKindOf: OrderedCollection).\r\tself assert: (result anySatisfy: [ :e | e isKindOf: Node ]).\r\tself assert: (result anySatisfy: [ :e | e name = \'a\']).\r\tself assert: (result anySatisfy: [ :e | (e isKindOf: Node) \r\t\tifTrue:[ e children isEmpty \r\t\t\tifTrue:[false] \r\t\t\tifFalse:[e children first name= \'b\']]\r\t\tifFalse:[false]\r\t\t]).\r\tself assert: (result at:1) allChildrenWeight = 26.2.\r\tself assert: (result at:1) name equals:\'a\'.\r\tself assert:(result at:1) children first name equals:\'b\'.\r\tself assert:(result at:1) children first children first contents equals:\'c\'.\r\t\r\tstring:= \'{\r    \"id\": 1,\r    \"tags\": [\"home\", \"green\"]\r}\'.\r\tresult:= ParserGenerator parseWithOrder: string.\r\tself halt.\r\tself assert: (result isKindOf: OrderedCollection).\r\tself assert: (result anySatisfy: [ :e | e isKindOf: Node ]).\r\tself assert: (result at:1) allChildrenWeight = 26.2.\r\tself assert: (result at:1) name equals:\'a\'.\r\tself assert:(result at:1) children first name equals:\'b\'.\r\tself assert:(result at:1) children first children first contents equals:\'c\'.\r',			#stamp : 'MathiasFuchs 12/31/2016 13:56',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T13:58:36.23845+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '16' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #BruteForceParserGeneratorTest,				#isMetaSide : false			},			#name : #testParseWithOrder,			#protocol : #tests,			#sourceCode : 'testParseWithOrder\r\t|string result |\r\tstring:= \'<a>\r\t<b>c</b>\r</a>\'.\r\tresult:= ParserGenerator parseWithOrder: string.\r\t\r\tself assert: (result isKindOf: OrderedCollection).\r\tself assert: (result anySatisfy: [ :e | e isKindOf: Node ]).\r\tself assert: (result anySatisfy: [ :e | e name = \'a\']).\r\tself assert: (result anySatisfy: [ :e | (e isKindOf: Node) \r\t\tifTrue:[ e children isEmpty \r\t\t\tifTrue:[false] \r\t\t\tifFalse:[e children first name= \'b\']]\r\t\tifFalse:[false]\r\t\t]).\r\tself assert: (result at:1) allChildrenWeight = 26.2.\r\tself assert: (result at:1) name equals:\'a\'.\r\tself assert:(result at:1) children first name equals:\'b\'.\r\tself assert:(result at:1) children first children first contents equals:\'c\'.\r\t\r\tstring:= \'{\r    \"id\": 1,\r    \"tags\": [\"home\", \"green\"]\r}\'.\r\tresult:= ParserGenerator parseWithOrder: string.\r\tself halt.\r\tself assert: (result isKindOf: OrderedCollection).\r\tself assert: (result anySatisfy: [ :e | e isKindOf: Node ]).\r\tself assert: (result at:1) allChildrenWeight = 26.2.\r\tself assert: (result at:1) name equals:\'a\'.\r\tself assert:(result at:1) children first name equals:\'b\'.\r\tself assert:(result at:1) children first children first contents equals:\'c\'.\r',			#stamp : 'MathiasFuchs 12/31/2016 13:56',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #BruteForceParserGeneratorTest,				#isMetaSide : false			},			#name : #testParseWithOrder,			#protocol : #tests,			#sourceCode : 'testParseWithOrder\r\t|string result |\r\tstring:= \'<a>\r\t<b>c</b>\r</a>\'.\r\tresult:= ParserGenerator parseWithOrder: string.\r\t\r\tself assert: (result isKindOf: OrderedCollection).\r\tself assert: (result anySatisfy: [ :e | e isKindOf: Node ]).\r\tself assert: (result anySatisfy: [ :e | e name = \'a\']).\r\tself assert: (result anySatisfy: [ :e | (e isKindOf: Node) \r\t\tifTrue:[ e children isEmpty \r\t\t\tifTrue:[false] \r\t\t\tifFalse:[e children first name= \'b\']]\r\t\tifFalse:[false]\r\t\t]).\r\tself assert: (result at:1) allChildrenWeight = 26.2.\r\tself assert: (result at:1) name equals:\'a\'.\r\tself assert:(result at:1) children first name equals:\'b\'.\r\tself assert:(result at:1) children first children first contents equals:\'c\'.\r\t\r\tstring:= \'{\r    \"id\": 1,\r    \"name\": \"A green door\",\r    \"price\": 12.50,\r    \"tags\": [\"home\", \"green\"]\r}\'.\r\tresult:= ParserGenerator parseWithOrder: string.\r\tself halt.\r\tself assert: (result isKindOf: OrderedCollection).\r\tself assert: (result anySatisfy: [ :e | e isKindOf: Node ]).\r\tself assert: (result at:1) allChildrenWeight = 26.2.\r\tself assert: (result at:1) name equals:\'a\'.\r\tself assert:(result at:1) children first name equals:\'b\'.\r\tself assert:(result at:1) children first children first contents equals:\'c\'.\r',			#stamp : 'MathiasFuchs 12/31/2016 13:58',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T14:02:12.16945+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '17' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #BruteForceParserGeneratorTest,				#isMetaSide : false			},			#name : #testParseWithOrder,			#protocol : #tests,			#sourceCode : 'testParseWithOrder\r\t|string result |\r\tstring:= \'<a>\r\t<b>c</b>\r</a>\'.\r\tresult:= ParserGenerator parseWithOrder: string.\r\t\r\tself assert: (result isKindOf: OrderedCollection).\r\tself assert: (result anySatisfy: [ :e | e isKindOf: Node ]).\r\tself assert: (result anySatisfy: [ :e | e name = \'a\']).\r\tself assert: (result anySatisfy: [ :e | (e isKindOf: Node) \r\t\tifTrue:[ e children isEmpty \r\t\t\tifTrue:[false] \r\t\t\tifFalse:[e children first name= \'b\']]\r\t\tifFalse:[false]\r\t\t]).\r\tself assert: (result at:1) allChildrenWeight = 26.2.\r\tself assert: (result at:1) name equals:\'a\'.\r\tself assert:(result at:1) children first name equals:\'b\'.\r\tself assert:(result at:1) children first children first contents equals:\'c\'.\r\t\r\tstring:= \'{\r    \"id\": 1,\r    \"name\": \"A green door\",\r    \"price\": 12.50,\r    \"tags\": [\"home\", \"green\"]\r}\'.\r\tresult:= ParserGenerator parseWithOrder: string.\r\tself halt.\r\tself assert: (result isKindOf: OrderedCollection).\r\tself assert: (result anySatisfy: [ :e | e isKindOf: Node ]).\r\tself assert: (result at:1) allChildrenWeight = 26.2.\r\tself assert: (result at:1) name equals:\'a\'.\r\tself assert:(result at:1) children first name equals:\'b\'.\r\tself assert:(result at:1) children first children first contents equals:\'c\'.\r',			#stamp : 'MathiasFuchs 12/31/2016 13:58',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #BruteForceParserGeneratorTest,				#isMetaSide : false			},			#name : #testParseWithOrder,			#protocol : #tests,			#sourceCode : 'testParseWithOrder\r\t|string result |\r\tstring:= \'<a>\r\t<b>c</b>\r</a>\'.\r\tresult:= ParserGenerator parseWithOrder: string.\r\t\r\tself assert: (result isKindOf: OrderedCollection).\r\tself assert: (result anySatisfy: [ :e | e isKindOf: Node ]).\r\tself assert: (result anySatisfy: [ :e | e name = \'a\']).\r\tself assert: (result anySatisfy: [ :e | (e isKindOf: Node) \r\t\tifTrue:[ e children isEmpty \r\t\t\tifTrue:[false] \r\t\t\tifFalse:[e children first name= \'b\']]\r\t\tifFalse:[false]\r\t\t]).\r\tself assert: (result at:1) allChildrenWeight = 26.2.\r\tself assert: (result at:1) name equals:\'a\'.\r\tself assert:(result at:1) children first name equals:\'b\'.\r\tself assert:(result at:1) children first children first contents equals:\'c\'.\r\t\r\tstring:= \'{\r    \"id\": 1,\r    \"name\": \"A green door\",\r    \"price\": 1250,\r    \"tags\": [\"home\", \"green\"]\r}\'.\r\tresult:= ParserGenerator parseWithOrder: string.\r\tself halt.\r\tself assert: (result isKindOf: OrderedCollection).\r\tself assert: (result anySatisfy: [ :e | e isKindOf: Node ]).\r\tself assert: (result at:1) allChildrenWeight = 26.2.\r\tself assert: (result at:1) name equals:\'a\'.\r\tself assert:(result at:1) children first name equals:\'b\'.\r\tself assert:(result at:1) children first children first contents equals:\'c\'.\r',			#stamp : 'MathiasFuchs 12/31/2016 14:02',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T14:03:14.89545+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '18' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'StringParserFactory class',				#isMetaSide : true			},			#name : #identifierDigit,			#protocol : #'as yet unclassified',			#sourceCode : 'identifierDigit\r\t^ (self new)\r\t\tbegin: (#digit asParser / $- asParser / $+ asParser) and trim;\r\t\tend: (#word asParser / #letter asParser / $- asParser / $+ asParser) not trim;\r\t\tescape: PPFailingParser new;\r\t\tgenerateParser',			#stamp : 'Icewater 12/31/2016 11:48:14',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'StringParserFactory class',				#isMetaSide : true			},			#name : #identifierDigit,			#protocol : #'as yet unclassified',			#sourceCode : 'identifierDigit\r\t^ (self new)\r\t\tbegin: (#digit asParser / $- asParser / $+ asParser) and trim;\r\t\tend: (#word asParser / #letter asParser / $- asParser / $+ asParser /$. asParser) not trim;\r\t\tescape: PPFailingParser new;\r\t\tgenerateParser',			#stamp : 'MathiasFuchs 12/31/2016 14:03',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T14:03:57.66745+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '19' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #BruteForceParserGeneratorTest,				#isMetaSide : false			},			#name : #testParseWithOrder,			#protocol : #tests,			#sourceCode : 'testParseWithOrder\r\t|string result |\r\tstring:= \'<a>\r\t<b>c</b>\r</a>\'.\r\tresult:= ParserGenerator parseWithOrder: string.\r\t\r\tself assert: (result isKindOf: OrderedCollection).\r\tself assert: (result anySatisfy: [ :e | e isKindOf: Node ]).\r\tself assert: (result anySatisfy: [ :e | e name = \'a\']).\r\tself assert: (result anySatisfy: [ :e | (e isKindOf: Node) \r\t\tifTrue:[ e children isEmpty \r\t\t\tifTrue:[false] \r\t\t\tifFalse:[e children first name= \'b\']]\r\t\tifFalse:[false]\r\t\t]).\r\tself assert: (result at:1) allChildrenWeight = 26.2.\r\tself assert: (result at:1) name equals:\'a\'.\r\tself assert:(result at:1) children first name equals:\'b\'.\r\tself assert:(result at:1) children first children first contents equals:\'c\'.\r\t\r\tstring:= \'{\r    \"id\": 1,\r    \"name\": \"A green door\",\r    \"price\": 1250,\r    \"tags\": [\"home\", \"green\"]\r}\'.\r\tresult:= ParserGenerator parseWithOrder: string.\r\tself halt.\r\tself assert: (result isKindOf: OrderedCollection).\r\tself assert: (result anySatisfy: [ :e | e isKindOf: Node ]).\r\tself assert: (result at:1) allChildrenWeight = 26.2.\r\tself assert: (result at:1) name equals:\'a\'.\r\tself assert:(result at:1) children first name equals:\'b\'.\r\tself assert:(result at:1) children first children first contents equals:\'c\'.\r',			#stamp : 'MathiasFuchs 12/31/2016 14:02',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #BruteForceParserGeneratorTest,				#isMetaSide : false			},			#name : #testParseWithOrder,			#protocol : #tests,			#sourceCode : 'testParseWithOrder\r\t|string result |\r\tstring:= \'<a>\r\t<b>c</b>\r</a>\'.\r\tresult:= ParserGenerator parseWithOrder: string.\r\t\r\tself assert: (result isKindOf: OrderedCollection).\r\tself assert: (result anySatisfy: [ :e | e isKindOf: Node ]).\r\tself assert: (result anySatisfy: [ :e | e name = \'a\']).\r\tself assert: (result anySatisfy: [ :e | (e isKindOf: Node) \r\t\tifTrue:[ e children isEmpty \r\t\t\tifTrue:[false] \r\t\t\tifFalse:[e children first name= \'b\']]\r\t\tifFalse:[false]\r\t\t]).\r\tself assert: (result at:1) allChildrenWeight = 26.2.\r\tself assert: (result at:1) name equals:\'a\'.\r\tself assert:(result at:1) children first name equals:\'b\'.\r\tself assert:(result at:1) children first children first contents equals:\'c\'.\r\t\r\tstring:= \'{\r    \"id\": 1,\r    \"name\": \"A green door\",\r    \"price\": 12.50,\r    \"tags\": [\"home\", \"green\"]\r}\'.\r\tresult:= ParserGenerator parseWithOrder: string.\r\tself halt.\r\tself assert: (result isKindOf: OrderedCollection).\r\tself assert: (result anySatisfy: [ :e | e isKindOf: Node ]).\r\tself assert: (result at:1) allChildrenWeight = 26.2.\r\tself assert: (result at:1) name equals:\'a\'.\r\tself assert:(result at:1) children first name equals:\'b\'.\r\tself assert:(result at:1) children first children first contents equals:\'c\'.\r',			#stamp : 'MathiasFuchs 12/31/2016 14:03',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T14:12:13.40645+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '20' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #BruteForceParserGeneratorTest,				#isMetaSide : false			},			#name : #testParseWithOrder,			#protocol : #tests,			#sourceCode : 'testParseWithOrder\r\t|string result |\r\tstring:= \'<a>\r\t<b>c</b>\r</a>\'.\r\tresult:= ParserGenerator parseWithOrder: string.\r\t\r\tself assert: (result isKindOf: OrderedCollection).\r\tself assert: (result anySatisfy: [ :e | e isKindOf: Node ]).\r\tself assert: (result anySatisfy: [ :e | e name = \'a\']).\r\tself assert: (result anySatisfy: [ :e | (e isKindOf: Node) \r\t\tifTrue:[ e children isEmpty \r\t\t\tifTrue:[false] \r\t\t\tifFalse:[e children first name= \'b\']]\r\t\tifFalse:[false]\r\t\t]).\r\tself assert: (result at:1) allChildrenWeight = 26.2.\r\tself assert: (result at:1) name equals:\'a\'.\r\tself assert:(result at:1) children first name equals:\'b\'.\r\tself assert:(result at:1) children first children first contents equals:\'c\'.\r\t\r\tstring:= \'{\r    \"id\": 1,\r    \"name\": \"A green door\",\r    \"price\": 12.50,\r    \"tags\": [\"home\", \"green\"]\r}\'.\r\tresult:= ParserGenerator parseWithOrder: string.\r\tself halt.\r\tself assert: (result isKindOf: OrderedCollection).\r\tself assert: (result anySatisfy: [ :e | e isKindOf: Node ]).\r\tself assert: (result at:1) allChildrenWeight = 26.2.\r\tself assert: (result at:1) name equals:\'a\'.\r\tself assert:(result at:1) children first name equals:\'b\'.\r\tself assert:(result at:1) children first children first contents equals:\'c\'.\r',			#stamp : 'MathiasFuchs 12/31/2016 14:03',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #BruteForceParserGeneratorTest,				#isMetaSide : false			},			#name : #testParseWithOrder,			#protocol : #tests,			#sourceCode : 'testParseWithOrder\r\t|string result |\r\tstring:= \'<a>\r\t<b>c</b>\r</a>\'.\r\tresult:= ParserGenerator parseWithOrder: string.\r\t\r\tself assert: (result isKindOf: OrderedCollection).\r\tself assert: (result anySatisfy: [ :e | e isKindOf: Node ]).\r\tself assert: (result anySatisfy: [ :e | e name = \'a\']).\r\tself assert: (result anySatisfy: [ :e | (e isKindOf: Node) \r\t\tifTrue:[ e children isEmpty \r\t\t\tifTrue:[false] \r\t\t\tifFalse:[e children first name= \'b\']]\r\t\tifFalse:[false]\r\t\t]).\r\tself assert: (result at:1) allChildrenWeight = 26.2.\r\tself assert: (result at:1) name equals:\'a\'.\r\tself assert:(result at:1) children first name equals:\'b\'.\r\tself assert:(result at:1) children first children first contents equals:\'c\'.\r\t\r\tstring:= \'{\r    \"id\": 1,\r    \"name\": \"A green door\",\r    \"price\": 12.50,\r    \"tags\": [\"home\", \"green\"]\r}\'.\r\tresult:= ParserGenerator parseWithOrder: string.\r\tself halt.\r\tself assert: (result isKindOf: OrderedCollection).\r\tself assert: (result anySatisfy: [ :e | e isKindOf: Node ]).\r\tself assert: (result at:1) allChildrenWeight = 22.\r\tself assert:(result at:1) children first name equals:\'id\'.\r\tself assert:(result at:1) children second name equals:\'name\'.\r\tself assert:(result at:1) children third name equals:\'price\'.\r\tself assert:(result at:1) children fourth name equals:\'tags\'.\r\tself assert:(result at:1) children fourth children first isKindOf: Collection.\r',			#stamp : 'MathiasFuchs 12/31/2016 14:12',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T14:12:44.43545+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '21' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseWithOrder: input\r\t|parsedResults|\r\t\r\tparsedResults := OrderedCollection new.\r\r\t\r\tparsedResults := self parse: input.\r\t\r\t^\t (parsedResults sorted: [ :eltA :eltB | (eltA allChildrenWeight > eltB allChildrenWeight) & (eltA allChildrenSeas < eltB allChildrenSeas)]).\r\t\r\t\r\r',			#stamp : 'Icewater 12/31/2016 11:48:14',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseWithOrder: input\r\t|parsedResults|\r\t\r\tparsedResults := OrderedCollection new.\r\r\t\r\tparsedResults := self parse: input.\r\t\r\t^\t (parsedResults sorted: [ :eltA :eltB | (eltA allChildrenWeight > eltB allChildrenWeight)]).\r\t\r\t\"& (eltA allChildrenSeas < eltB allChildrenSeas)\"\r\r',			#stamp : 'MathiasFuchs 12/31/2016 14:12',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T14:16:22.08945+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '22' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '23' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #BruteForceParserGeneratorTest,				#isMetaSide : false			},			#name : #testParseWithOrder,			#protocol : #tests,			#sourceCode : 'testParseWithOrder\r\t|string result |\r\tstring:= \'<a>\r\t<b>c</b>\r</a>\'.\r\tresult:= ParserGenerator parseWithOrder: string.\r\t\r\tself assert: (result isKindOf: OrderedCollection).\r\tself assert: (result anySatisfy: [ :e | e isKindOf: Node ]).\r\tself assert: (result anySatisfy: [ :e | e name = \'a\']).\r\tself assert: (result anySatisfy: [ :e | (e isKindOf: Node) \r\t\tifTrue:[ e children isEmpty \r\t\t\tifTrue:[false] \r\t\t\tifFalse:[e children first name= \'b\']]\r\t\tifFalse:[false]\r\t\t]).\r\tself assert: (result at:1) allChildrenWeight = 26.2.\r\tself assert: (result at:1) name equals:\'a\'.\r\tself assert:(result at:1) children first name equals:\'b\'.\r\tself assert:(result at:1) children first children first contents equals:\'c\'.\r\t\r\tstring:= \'{\r    \"id\": 1,\r    \"name\": \"A green door\",\r    \"price\": 12.50,\r    \"tags\": [\"home\", \"green\"]\r}\'.\r\tresult:= ParserGenerator parseWithOrder: string.\r\tself halt.\r\tself assert: (result isKindOf: OrderedCollection).\r\tself assert: (result anySatisfy: [ :e | e isKindOf: Node ]).\r\tself assert: (result at:1) allChildrenWeight = 22.\r\tself assert:(result at:1) children first name equals:\'id\'.\r\tself assert:(result at:1) children second name equals:\'name\'.\r\tself assert:(result at:1) children third name equals:\'price\'.\r\tself assert:(result at:1) children fourth name equals:\'tags\'.\r\tself assert:(result at:1) children fourth children first isKindOf: Collection.\r',			#stamp : 'MathiasFuchs 12/31/2016 14:12',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #BruteForceParserGeneratorTest,				#isMetaSide : false			},			#name : #testParseWithOrder,			#protocol : #tests,			#sourceCode : 'testParseWithOrder\r\t|string result |\r\tstring:= \'<a>\r\t<b>c</b>\r</a>\'.\r\tresult:= ParserGenerator parseWithOrder: string.\r\t\r\tself assert: (result isKindOf: OrderedCollection).\r\tself assert: (result anySatisfy: [ :e | e isKindOf: Node ]).\r\tself assert: (result anySatisfy: [ :e | e name = \'a\']).\r\tself assert: (result anySatisfy: [ :e | (e isKindOf: Node) \r\t\tifTrue:[ e children isEmpty \r\t\t\tifTrue:[false] \r\t\t\tifFalse:[e children first name= \'b\']]\r\t\tifFalse:[false]\r\t\t]).\r\tself assert: (result at:1) allChildrenWeight = 26.2.\r\tself assert: (result at:1) name equals:\'a\'.\r\tself assert:(result at:1) children first name equals:\'b\'.\r\tself assert:(result at:1) children first children first contents equals:\'c\'.\r\t\r\t\"string:= \'{\r    \"\"id\"\": 1,\r    \"\"name\"\": \"\"A green door\"\",\r    \"\"price\"\": 12.50,\r    \"\"tags\"\": [\"\"home\"\", \"\"green\"\"]\r}\'.\r\tresult:= ParserGenerator parseWithOrder: string.\r\tself halt.\r\tself assert: (result isKindOf: OrderedCollection).\r\tself assert: (result anySatisfy: [ :e | e isKindOf: Node ]).\r\tself assert: (result at:1) allChildrenWeight = 22.\r\tself assert:(result at:1) children first name equals:\'id\'.\r\tself assert:(result at:1) children second name equals:\'name\'.\r\tself assert:(result at:1) children third name equals:\'price\'.\r\tself assert:(result at:1) children fourth name equals:\'tags\'.\r\tself assert:(result at:1) children fourth children first isKindOf: Collection.\"\r',			#stamp : 'MathiasFuchs 12/31/2016 14:16',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T14:18:48.28545+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '23' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults |\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\t\"not 100% sure about this, can be done better?\"\r\t\"First item has to be short, else this will propbably not work, add assertion for it?\"\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t([ (parser parse:(aSet first)) isPetitFailure\t\t ] valueWithin: 100 milliSeconds onTimeout:(true)) ].\r\t\t\t\t\r\t\"try to order, have to redo this, absolutely. This is broken ugly :S \"\t\t\r\tparsers:= (parsers sorted: [ :eltA :eltB | \r\t\t|a b|\r\t\t\r\t\ta:= (eltA parse: (aSet first)).\r\t\tb:= (eltB parse: (aSet first)).\r\t\t\r\t\t(a isKindOf:Collection)\r\t\tifTrue:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: a;\r\t\t\tyourself]\r\t\tifFalse:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: a;\r\t\t\tyourself].\r\t\t\r\t\t(b isKindOf:Collection)\r\t\tifTrue:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: b;\r\t\t\tyourself]\r\t\tifFalse:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: b;\r\t\t\tyourself].\r\t\t\r\t\t (a allChildrenWeight > b allChildrenWeight) & (a allChildrenSeas < b allChildrenSeas) ] ).\r\t\r\tparsers:= parsers first:60.\r\tself halt.\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 13:47',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults solutionsOfFirst|\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\tsolutionsOfFirst:= OrderedCollection new.\r\t\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\t\"not 100% sure about this, can be done better?\"\r\t\"First item has to be short, else this will propbably not work, add assertion for it?\"\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t([ (parser parse:(aSet first)) isPetitFailure\t\t ] valueWithin: 100 milliSeconds onTimeout:(true)) ].\r\t\t\t\t\r\t\t\r\t\t\t\t\r\t\"try to order, have to redo this, absolutely. This is broken ugly :S \"\t\t\r\tparsers:= (parsers sorted: [ :eltA :eltB | \r\t\t|a b|\r\t\t\r\t\ta:= (eltA parse: (aSet first)).\r\t\tb:= (eltB parse: (aSet first)).\r\t\t\r\t\t(a isKindOf:Collection)\r\t\tifTrue:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: a;\r\t\t\tyourself]\r\t\tifFalse:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: a;\r\t\t\tyourself].\r\t\t\r\t\t(b isKindOf:Collection)\r\t\tifTrue:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: b;\r\t\t\tyourself]\r\t\tifFalse:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: b;\r\t\t\tyourself].\r\t\t\r\t\t (a allChildrenWeight > b allChildrenWeight) & (a allChildrenSeas < b allChildrenSeas) ] ).\r\t\r\tparsers:= parsers first:60.\r\tself halt.\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 14:18',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T14:21:47.10945+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '24' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults solutionsOfFirst|\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\tsolutionsOfFirst:= OrderedCollection new.\r\t\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\t\"not 100% sure about this, can be done better?\"\r\t\"First item has to be short, else this will propbably not work, add assertion for it?\"\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t([ (parser parse:(aSet first)) isPetitFailure\t\t ] valueWithin: 100 milliSeconds onTimeout:(true)) ].\r\t\t\t\t\r\t\t\r\t\t\t\t\r\t\"try to order, have to redo this, absolutely. This is broken ugly :S \"\t\t\r\tparsers:= (parsers sorted: [ :eltA :eltB | \r\t\t|a b|\r\t\t\r\t\ta:= (eltA parse: (aSet first)).\r\t\tb:= (eltB parse: (aSet first)).\r\t\t\r\t\t(a isKindOf:Collection)\r\t\tifTrue:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: a;\r\t\t\tyourself]\r\t\tifFalse:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: a;\r\t\t\tyourself].\r\t\t\r\t\t(b isKindOf:Collection)\r\t\tifTrue:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: b;\r\t\t\tyourself]\r\t\tifFalse:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: b;\r\t\t\tyourself].\r\t\t\r\t\t (a allChildrenWeight > b allChildrenWeight) & (a allChildrenSeas < b allChildrenSeas) ] ).\r\t\r\tparsers:= parsers first:60.\r\tself halt.\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 14:18',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults solutionsOfFirst|\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\tsolutionsOfFirst:= OrderedCollection new.\r\t\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\t\"not 100% sure about this, can be done better?\"\r\t\"First item has to be short, else this will propbably not work, add assertion for it?\"\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t|res|\r\t\t\tres:= [parser parse:(aSet first)] valueWithin:100 milliSeconds onTimeout: (true).\r\t\t\t(res isPetitFailure) ].\r\t\t\t\t\r\t\t\r\t\t\t\t\r\t\"try to order, have to redo this, absolutely. This is broken ugly :S \"\t\t\r\tparsers:= (parsers sorted: [ :eltA :eltB | \r\t\t|a b|\r\t\t\r\t\ta:= (eltA parse: (aSet first)).\r\t\tb:= (eltB parse: (aSet first)).\r\t\t\r\t\t(a isKindOf:Collection)\r\t\tifTrue:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: a;\r\t\t\tyourself]\r\t\tifFalse:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: a;\r\t\t\tyourself].\r\t\t\r\t\t(b isKindOf:Collection)\r\t\tifTrue:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: b;\r\t\t\tyourself]\r\t\tifFalse:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: b;\r\t\t\tyourself].\r\t\t\r\t\t (a allChildrenWeight > b allChildrenWeight) & (a allChildrenSeas < b allChildrenSeas) ] ).\r\t\r\tparsers:= parsers first:60.\r\tself halt.\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 14:21',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T14:24:11.88645+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '25' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults solutionsOfFirst|\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\tsolutionsOfFirst:= OrderedCollection new.\r\t\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\t\"not 100% sure about this, can be done better?\"\r\t\"First item has to be short, else this will propbably not work, add assertion for it?\"\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t|res|\r\t\t\tres:= [parser parse:(aSet first)] valueWithin:100 milliSeconds onTimeout: (true).\r\t\t\t(res isPetitFailure) ].\r\t\t\t\t\r\t\t\r\t\t\t\t\r\t\"try to order, have to redo this, absolutely. This is broken ugly :S \"\t\t\r\tparsers:= (parsers sorted: [ :eltA :eltB | \r\t\t|a b|\r\t\t\r\t\ta:= (eltA parse: (aSet first)).\r\t\tb:= (eltB parse: (aSet first)).\r\t\t\r\t\t(a isKindOf:Collection)\r\t\tifTrue:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: a;\r\t\t\tyourself]\r\t\tifFalse:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: a;\r\t\t\tyourself].\r\t\t\r\t\t(b isKindOf:Collection)\r\t\tifTrue:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: b;\r\t\t\tyourself]\r\t\tifFalse:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: b;\r\t\t\tyourself].\r\t\t\r\t\t (a allChildrenWeight > b allChildrenWeight) & (a allChildrenSeas < b allChildrenSeas) ] ).\r\t\r\tparsers:= parsers first:60.\r\tself halt.\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 14:21',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults solutionsOfFirst|\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\tsolutionsOfFirst:= OrderedCollection new.\r\t\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\tparsers do: [ :parser |solutionsOfFirst add:( parser parse:(aSet first)) ].\r\tsolutionsOfFirst removeAllSuchThat: [ :elt |\r\t\t(elt isKindOf: Node) not ].\r\t\r\tself halt.\r\t\r\t\"not 100% sure about this, can be done better?\"\r\t\"First item has to be short, else this will propbably not work, add assertion for it?\"\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t|res|\r\t\t\tres:= [parser parse:(aSet first)] valueWithin:100 milliSeconds onTimeout: (true).\r\t\t\t(res isPetitFailure) ].\r\t\t\t\t\r\t\t\r\t\t\t\t\r\t\"try to order, have to redo this, absolutely. This is broken ugly :S \"\t\t\r\tparsers:= (parsers sorted: [ :eltA :eltB | \r\t\t|a b|\r\t\t\r\t\ta:= (eltA parse: (aSet first)).\r\t\tb:= (eltB parse: (aSet first)).\r\t\t\r\t\t(a isKindOf:Collection)\r\t\tifTrue:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: a;\r\t\t\tyourself]\r\t\tifFalse:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: a;\r\t\t\tyourself].\r\t\t\r\t\t(b isKindOf:Collection)\r\t\tifTrue:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: b;\r\t\t\tyourself]\r\t\tifFalse:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: b;\r\t\t\tyourself].\r\t\t\r\t\t (a allChildrenWeight > b allChildrenWeight) & (a allChildrenSeas < b allChildrenSeas) ] ).\r\t\r\tparsers:= parsers first:60.\r\tself halt.\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 14:24',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T14:28:06.45145+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '26' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults solutionsOfFirst|\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\tsolutionsOfFirst:= OrderedCollection new.\r\t\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\tparsers do: [ :parser |solutionsOfFirst add:( parser parse:(aSet first)) ].\r\tsolutionsOfFirst removeAllSuchThat: [ :elt |\r\t\t(elt isKindOf: Node) not ].\r\t\r\tself halt.\r\t\r\t\"not 100% sure about this, can be done better?\"\r\t\"First item has to be short, else this will propbably not work, add assertion for it?\"\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t|res|\r\t\t\tres:= [parser parse:(aSet first)] valueWithin:100 milliSeconds onTimeout: (true).\r\t\t\t(res isPetitFailure) ].\r\t\t\t\t\r\t\t\r\t\t\t\t\r\t\"try to order, have to redo this, absolutely. This is broken ugly :S \"\t\t\r\tparsers:= (parsers sorted: [ :eltA :eltB | \r\t\t|a b|\r\t\t\r\t\ta:= (eltA parse: (aSet first)).\r\t\tb:= (eltB parse: (aSet first)).\r\t\t\r\t\t(a isKindOf:Collection)\r\t\tifTrue:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: a;\r\t\t\tyourself]\r\t\tifFalse:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: a;\r\t\t\tyourself].\r\t\t\r\t\t(b isKindOf:Collection)\r\t\tifTrue:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: b;\r\t\t\tyourself]\r\t\tifFalse:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: b;\r\t\t\tyourself].\r\t\t\r\t\t (a allChildrenWeight > b allChildrenWeight) & (a allChildrenSeas < b allChildrenSeas) ] ).\r\t\r\tparsers:= parsers first:60.\r\tself halt.\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 14:24',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults solutionsOfFirst|\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\tsolutionsOfFirst:= OrderedCollection new.\r\t\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\tparsers do: [ :parser |\r\t\t|res|\r\t\tres:= [parser parse:(aSet first)] valueWithin:150 milliSeconds onTimeout: (#failure).\r\t\tsolutionsOfFirst add:res ].\r\t\r\tsolutionsOfFirst removeAllSuchThat: [ :elt |\r\t\t(elt isKindOf: Node) not ].\r\t\r\tself halt.\r\t\r\t\"not 100% sure about this, can be done better?\"\r\t\"First item has to be short, else this will propbably not work, add assertion for it?\"\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t|res|\r\t\t\tres:= [parser parse:(aSet first)] valueWithin:100 milliSeconds onTimeout: (true).\r\t\t\t(res isPetitFailure) ].\r\t\t\t\t\r\t\t\r\t\t\t\t\r\t\"try to order, have to redo this, absolutely. This is broken ugly :S \"\t\t\r\tparsers:= (parsers sorted: [ :eltA :eltB | \r\t\t|a b|\r\t\t\r\t\ta:= (eltA parse: (aSet first)).\r\t\tb:= (eltB parse: (aSet first)).\r\t\t\r\t\t(a isKindOf:Collection)\r\t\tifTrue:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: a;\r\t\t\tyourself]\r\t\tifFalse:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: a;\r\t\t\tyourself].\r\t\t\r\t\t(b isKindOf:Collection)\r\t\tifTrue:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: b;\r\t\t\tyourself]\r\t\tifFalse:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: b;\r\t\t\tyourself].\r\t\t\r\t\t (a allChildrenWeight > b allChildrenWeight) & (a allChildrenSeas < b allChildrenSeas) ] ).\r\t\r\tparsers:= parsers first:60.\r\tself halt.\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 14:28',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T14:30:21.89945+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '27' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults solutionsOfFirst|\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\tsolutionsOfFirst:= OrderedCollection new.\r\t\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\tparsers do: [ :parser |\r\t\t|res|\r\t\tres:= [parser parse:(aSet first)] valueWithin:150 milliSeconds onTimeout: (#failure).\r\t\tsolutionsOfFirst add:res ].\r\t\r\tsolutionsOfFirst removeAllSuchThat: [ :elt |\r\t\t(elt isKindOf: Node) not ].\r\t\r\tself halt.\r\t\r\t\"not 100% sure about this, can be done better?\"\r\t\"First item has to be short, else this will propbably not work, add assertion for it?\"\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t|res|\r\t\t\tres:= [parser parse:(aSet first)] valueWithin:100 milliSeconds onTimeout: (true).\r\t\t\t(res isPetitFailure) ].\r\t\t\t\t\r\t\t\r\t\t\t\t\r\t\"try to order, have to redo this, absolutely. This is broken ugly :S \"\t\t\r\tparsers:= (parsers sorted: [ :eltA :eltB | \r\t\t|a b|\r\t\t\r\t\ta:= (eltA parse: (aSet first)).\r\t\tb:= (eltB parse: (aSet first)).\r\t\t\r\t\t(a isKindOf:Collection)\r\t\tifTrue:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: a;\r\t\t\tyourself]\r\t\tifFalse:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: a;\r\t\t\tyourself].\r\t\t\r\t\t(b isKindOf:Collection)\r\t\tifTrue:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: b;\r\t\t\tyourself]\r\t\tifFalse:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: b;\r\t\t\tyourself].\r\t\t\r\t\t (a allChildrenWeight > b allChildrenWeight) & (a allChildrenSeas < b allChildrenSeas) ] ).\r\t\r\tparsers:= parsers first:60.\r\tself halt.\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 14:28',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults solutionsOfFirst|\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\tsolutionsOfFirst:= OrderedCollection new.\r\t\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\tparsers do: [ :parser |\r\t\t|res|\r\t\tres:= [parser parse:(aSet first)] valueWithin:150 milliSeconds onTimeout: (#failure).\r\t\tsolutionsOfFirst add:res ].\r\t\r\tsolutionsOfFirst removeAllSuchThat: [ :elt |\r\t\t(elt isKindOf: Node) not ].\r\t\r\r\tparsers:= OrderedCollection new.\r\tsolutionsOfFirst do: [ :elt |\r\t\tparsers add: (elt parserFactory generateParser) ].\r\tself halt.\r\t\r\t\"not 100% sure about this, can be done better?\"\r\t\"First item has to be short, else this will propbably not work, add assertion for it?\"\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t|res|\r\t\t\tres:= [parser parse:(aSet first)] valueWithin:100 milliSeconds onTimeout: (true).\r\t\t\t(res isPetitFailure) ].\r\t\t\t\t\r\t\t\r\t\t\t\t\r\t\"try to order, have to redo this, absolutely. This is broken ugly :S \"\t\t\r\tparsers:= (parsers sorted: [ :eltA :eltB | \r\t\t|a b|\r\t\t\r\t\ta:= (eltA parse: (aSet first)).\r\t\tb:= (eltB parse: (aSet first)).\r\t\t\r\t\t(a isKindOf:Collection)\r\t\tifTrue:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: a;\r\t\t\tyourself]\r\t\tifFalse:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: a;\r\t\t\tyourself].\r\t\t\r\t\t(b isKindOf:Collection)\r\t\tifTrue:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: b;\r\t\t\tyourself]\r\t\tifFalse:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: b;\r\t\t\tyourself].\r\t\t\r\t\t (a allChildrenWeight > b allChildrenWeight) & (a allChildrenSeas < b allChildrenSeas) ] ).\r\t\r\tparsers:= parsers first:60.\r\tself halt.\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 14:30',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T14:30:32.53145+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '28' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '29' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #SetValidator,				#isMetaSide : false			},			#name : #'validate:correctParser:',			#protocol : #'as yet unclassified',			#sourceCode : 'validate: aCollection correctParser: correctParser\r\t|parsedInputs correctlyParsedInputs finalResults|\r\t\r\tself halt.\r\tparsedInputs:=  ParserGenerator parseSetWithOrder: aCollection.\r\tcorrectlyParsedInputs:= OrderedCollection new.\r\tfinalResults:= OrderedCollection new.\r\t\r\t\"get the correct parsed String\"\r\t(aCollection do: [ :string |\r\t\tcorrectlyParsedInputs add:(correctParser parse:string)\t ]).\r\t\r\r\t(1 to: parsedInputs size) do: [ :index |\r\t\t|visitor correctOutput allResults sortedResults|\r\t\t\tvisitor:= ExportVisitor new. \r\t\t\tsortedResults := SortedCollection sortBlock: [:c1 :c2 | c1 \t\t\tf1score >= c2 f1score].\r\t\t\tcorrectOutput:= (visitor visit: (correctlyParsedInputs at: \t\t\tindex)) output.\r\t\t\t\t\t\t\r\t\t\tallResults := (((ValidatorSuite new)\r\t\t\t\tcorrectResult: correctOutput;\r\t\t\t\tresults: (parsedInputs at: index);\r\t\t\t\tyourself) validate).\r\t\t\t\t\r\t\t\t\tallResults do: [ :result | (result isKindOf: ResultNode) & \t\t\t\t\t(result f1score isKindOf: Float)\r\t\t\t\t\tifTrue:[sortedResults add: result]].\r\t\t\t\t\r\t\t\t\tfinalResults add: (sortedResults at:1).\r\t\t\t\r\t\t ].\r\t^finalResults',			#stamp : 'MathiasFuchs 12/31/2016 13:36',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #SetValidator,				#isMetaSide : false			},			#name : #'validate:correctParser:',			#protocol : #'as yet unclassified',			#sourceCode : 'validate: aCollection correctParser: correctParser\r\t|parsedInputs correctlyParsedInputs finalResults|\r\t\r\t\r\tparsedInputs:=  ParserGenerator parseSetWithOrder: aCollection.\r\tcorrectlyParsedInputs:= OrderedCollection new.\r\tfinalResults:= OrderedCollection new.\r\t\r\t\"get the correct parsed String\"\r\t(aCollection do: [ :string |\r\t\tcorrectlyParsedInputs add:(correctParser parse:string)\t ]).\r\t\r\r\t(1 to: parsedInputs size) do: [ :index |\r\t\t|visitor correctOutput allResults sortedResults|\r\t\t\tvisitor:= ExportVisitor new. \r\t\t\tsortedResults := SortedCollection sortBlock: [:c1 :c2 | c1 \t\t\tf1score >= c2 f1score].\r\t\t\tcorrectOutput:= (visitor visit: (correctlyParsedInputs at: \t\t\tindex)) output.\r\t\t\t\t\t\t\r\t\t\tallResults := (((ValidatorSuite new)\r\t\t\t\tcorrectResult: correctOutput;\r\t\t\t\tresults: (parsedInputs at: index);\r\t\t\t\tyourself) validate).\r\t\t\t\t\r\t\t\t\tallResults do: [ :result | (result isKindOf: ResultNode) & \t\t\t\t\t(result f1score isKindOf: Float)\r\t\t\t\t\tifTrue:[sortedResults add: result]].\r\t\t\t\t\r\t\t\t\tfinalResults add: (sortedResults at:1).\r\t\t\t\r\t\t ].\r\t^finalResults',			#stamp : 'MathiasFuchs 12/31/2016 14:30',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T14:34:09.62545+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '29' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults solutionsOfFirst|\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\tsolutionsOfFirst:= OrderedCollection new.\r\t\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\tparsers do: [ :parser |\r\t\t|res|\r\t\tres:= [parser parse:(aSet first)] valueWithin:150 milliSeconds onTimeout: (#failure).\r\t\tsolutionsOfFirst add:res ].\r\t\r\tsolutionsOfFirst removeAllSuchThat: [ :elt |\r\t\t(elt isKindOf: Node) not ].\r\t\r\r\tparsers:= OrderedCollection new.\r\tsolutionsOfFirst do: [ :elt |\r\t\tparsers add: (elt parserFactory generateParser) ].\r\tself halt.\r\t\r\t\"not 100% sure about this, can be done better?\"\r\t\"First item has to be short, else this will propbably not work, add assertion for it?\"\r\t\tparsers removeAllSuchThat: [ :parser | \r\t\t\t|res|\r\t\t\tres:= [parser parse:(aSet first)] valueWithin:100 milliSeconds onTimeout: (true).\r\t\t\t(res isPetitFailure) ].\r\t\t\t\t\r\t\t\r\t\t\t\t\r\t\"try to order, have to redo this, absolutely. This is broken ugly :S \"\t\t\r\tparsers:= (parsers sorted: [ :eltA :eltB | \r\t\t|a b|\r\t\t\r\t\ta:= (eltA parse: (aSet first)).\r\t\tb:= (eltB parse: (aSet first)).\r\t\t\r\t\t(a isKindOf:Collection)\r\t\tifTrue:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: a;\r\t\t\tyourself]\r\t\tifFalse:[a:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: a;\r\t\t\tyourself].\r\t\t\r\t\t(b isKindOf:Collection)\r\t\tifTrue:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\tchildren: b;\r\t\t\tyourself]\r\t\tifFalse:[b:= (Element new)\r\t\t\tname:\'__ROOT__\';\r\t\t\tweight:0;\r\t\t\taddChild: b;\r\t\t\tyourself].\r\t\t\r\t\t (a allChildrenWeight > b allChildrenWeight) & (a allChildrenSeas < b allChildrenSeas) ] ).\r\t\r\tparsers:= parsers first:60.\r\tself halt.\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 14:30',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults solutionsOfFirst|\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\tsolutionsOfFirst:= OrderedCollection new.\r\t\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\tparsers do: [ :parser |\r\t\t|res|\r\t\tres:= [parser parse:(aSet first)] valueWithin:150 milliSeconds onTimeout: (#failure).\r\t\tsolutionsOfFirst add:res ].\r\t\r\tsolutionsOfFirst removeAllSuchThat: [ :elt |\r\t\t(elt isKindOf: Node) not ].\r\t\"sort them\"\r\t (solutionsOfFirst sorted: [ :eltA :eltB | (eltA allChildrenWeight > eltB allChildrenWeight)]).\r\tsolutionsOfFirst:= solutionsOfFirst first:50.\r\t\r\t\"recreate the parsers which are needed\"\r\tparsers:= OrderedCollection new.\r\tsolutionsOfFirst do: [ :elt |\r\t\tparsers add: (elt parserFactory generateParser) ].\r\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 14:34',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T15:03:41.29945+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '30' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '31' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #SetValidatorTest,				#isMetaSide : false			},			#name : #testValidate,			#protocol : #tests,			#sourceCode : 'testValidate\r|correctParser validator set result|\t\r\tcorrectParser:= XMLFactoryParser.\r\tvalidator:= SetValidator new.\r\tresult:= OrderedCollection new.\r\t\r\tset:= OrderedCollection new.\r\tset add:\'<a>b </a>\'.\r\tset add:\'<breakfast-menu>\r\t\t\t\t\t<food>\r\t\t\t\t\t\t<name>Belgian Waffles</name>\r\t\t\t\t\t\t<price>$5.95</price>\r\t\t\t\t\t\t<description>\r\t\t\t\t\t\t\ttwo of our famous Belgian Waffles with plenty of real \t\t\t\t\t\t\tmaple syrup\r\t\t\t\t\t\t</description>\r\t\t\t\t\t\t<calories>650</calories>\r\t\t\t\t\t</food>\r\t\t\t\t\t<food>\r\t\t\t\t\t\t<name>Strawberry Belgian Waffles</name>\r\t\t\t\t\t\t<price>$7.95</price>\r\t\t\t\t\t\t<description>\r\t\t\t\t\t\t\tlight Belgian waffles covered with strawberrys and \t\t\t\t\t\t\twhipped cream\r\t\t\t\t\t\t</description>\r\t\t\t\t\t\t<calories>900</calories>\r\t\t\t\t\t</food>\r\t\t\t\t</breakfast-menu>\'.\r\r\tresult:= validator validate: set correctParser:correctParser.\r\t\t\r\tself assert: (result isKindOf: OrderedCollection).\r\tself assert: (result allSatisfy: [ :e | e isKindOf: ResultNode ]).\r\tself assert: ((result at:1)  precision closeTo: 1).\r\tself assert: ((result at:1) recall closeTo:1).\r\tself assert: ((result at:1) f1score closeTo:1).\r\r',			#stamp : 'Icewater 12/31/2016 11:48:14',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #SetValidatorTest,				#isMetaSide : false			},			#name : #testValidate,			#protocol : #tests,			#sourceCode : 'testValidate\r|correctParser validator set result|\t\r\tcorrectParser:= XMLFactoryParser new.\r\tvalidator:= SetValidator new.\r\tresult:= OrderedCollection new.\r\t\r\tset:= OrderedCollection new.\r\tset add:\'<a>b </a>\'.\r\tset add:\'<breakfast-menu>\r\t\t\t\t\t<food>\r\t\t\t\t\t\t<name>Belgian Waffles</name>\r\t\t\t\t\t\t<price>$5.95</price>\r\t\t\t\t\t\t<description>\r\t\t\t\t\t\t\ttwo of our famous Belgian Waffles with plenty of real \t\t\t\t\t\t\tmaple syrup\r\t\t\t\t\t\t</description>\r\t\t\t\t\t\t<calories>650</calories>\r\t\t\t\t\t</food>\r\t\t\t\t\t<food>\r\t\t\t\t\t\t<name>Strawberry Belgian Waffles</name>\r\t\t\t\t\t\t<price>$7.95</price>\r\t\t\t\t\t\t<description>\r\t\t\t\t\t\t\tlight Belgian waffles covered with strawberrys and \t\t\t\t\t\t\twhipped cream\r\t\t\t\t\t\t</description>\r\t\t\t\t\t\t<calories>900</calories>\r\t\t\t\t\t</food>\r\t\t\t\t</breakfast-menu>\'.\r\r\tresult:= validator validate: set correctParser:correctParser.\r\t\t\r\tself assert: (result isKindOf: OrderedCollection).\r\tself assert: (result allSatisfy: [ :e | e isKindOf: ResultNode ]).\r\tself assert: ((result at:1)  precision closeTo: 1).\r\tself assert: ((result at:1) recall closeTo:1).\r\tself assert: ((result at:1) f1score closeTo:1).\r\r',			#stamp : 'MathiasFuchs 12/31/2016 15:03',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T15:05:22.16845+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '31' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '32' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults solutionsOfFirst|\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\tsolutionsOfFirst:= OrderedCollection new.\r\t\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\tparsers do: [ :parser |\r\t\t|res|\r\t\tres:= [parser parse:(aSet first)] valueWithin:150 milliSeconds onTimeout: (#failure).\r\t\tsolutionsOfFirst add:res ].\r\t\r\tsolutionsOfFirst removeAllSuchThat: [ :elt |\r\t\t(elt isKindOf: Node) not ].\r\t\"sort them\"\r\t (solutionsOfFirst sorted: [ :eltA :eltB | (eltA allChildrenWeight > eltB allChildrenWeight)]).\r\tsolutionsOfFirst:= solutionsOfFirst first:50.\r\t\r\t\"recreate the parsers which are needed\"\r\tparsers:= OrderedCollection new.\r\tsolutionsOfFirst do: [ :elt |\r\t\tparsers add: (elt parserFactory generateParser) ].\r\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 14:34',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults solutionsOfFirst|\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\tsolutionsOfFirst:= OrderedCollection new.\r\t\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\tparsers do: [ :parser |\r\t\t|res|\r\t\tres:= [parser parse:(aSet first)] valueWithin:150 milliSeconds onTimeout: (#failure).\r\t\tsolutionsOfFirst add:res ].\r\t\r\tsolutionsOfFirst removeAllSuchThat: [ :elt |\r\t\t(elt isKindOf: Node) not ].\r\t\"sort them\"\r\t (solutionsOfFirst sorted: [ :eltA :eltB | (eltA allChildrenWeight > eltB allChildrenWeight)]).\r\t\r\t(solutionsOfFirst size >50)\r\tifTrue: [\tsolutionsOfFirst:= solutionsOfFirst first:50  ].\r\r\t\r\t\"recreate the parsers which are needed\"\r\tparsers:= OrderedCollection new.\r\tsolutionsOfFirst do: [ :elt |\r\t\tparsers add: (elt parserFactory generateParser) ].\r\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 15:05',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T15:13:45.06545+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '32' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '33' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #SetValidator,				#isMetaSide : false			},			#name : #'validate:correctParser:',			#protocol : #'as yet unclassified',			#sourceCode : 'validate: aCollection correctParser: correctParser\r\t|parsedInputs correctlyParsedInputs finalResults|\r\t\r\t\r\tparsedInputs:=  ParserGenerator parseSetWithOrder: aCollection.\r\tcorrectlyParsedInputs:= OrderedCollection new.\r\tfinalResults:= OrderedCollection new.\r\t\r\t\"get the correct parsed String\"\r\t(aCollection do: [ :string |\r\t\tcorrectlyParsedInputs add:(correctParser parse:string)\t ]).\r\t\r\r\t(1 to: parsedInputs size) do: [ :index |\r\t\t|visitor correctOutput allResults sortedResults|\r\t\t\tvisitor:= ExportVisitor new. \r\t\t\tsortedResults := SortedCollection sortBlock: [:c1 :c2 | c1 \t\t\tf1score >= c2 f1score].\r\t\t\tcorrectOutput:= (visitor visit: (correctlyParsedInputs at: \t\t\tindex)) output.\r\t\t\t\t\t\t\r\t\t\tallResults := (((ValidatorSuite new)\r\t\t\t\tcorrectResult: correctOutput;\r\t\t\t\tresults: (parsedInputs at: index);\r\t\t\t\tyourself) validate).\r\t\t\t\t\r\t\t\t\tallResults do: [ :result | (result isKindOf: ResultNode) & \t\t\t\t\t(result f1score isKindOf: Float)\r\t\t\t\t\tifTrue:[sortedResults add: result]].\r\t\t\t\t\r\t\t\t\tfinalResults add: (sortedResults at:1).\r\t\t\t\r\t\t ].\r\t^finalResults',			#stamp : 'MathiasFuchs 12/31/2016 14:30',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #SetValidator,				#isMetaSide : false			},			#name : #'validate:correctParser:',			#protocol : #'as yet unclassified',			#sourceCode : 'validate: aCollection correctParser: correctParser\r\t|parsedInputs correctlyParsedInputs finalResults|\r\t\r\t\r\tparsedInputs:=  ParserGenerator parseSetWithOrder: aCollection.\r\tcorrectlyParsedInputs:= OrderedCollection new.\r\tfinalResults:= OrderedCollection new.\r\t\r\t\"get the correct parsed String\"\r\t(aCollection do: [ :string |\r\t\tcorrectlyParsedInputs add:(correctParser parse:string)\t ]).\r\t\r\r\t(1 to: parsedInputs size) do: [ :index |\r\t\t|visitor correctOutput allResults sortedResults|\r\t\t\tvisitor:= ExportVisitor new. \r\t\t\tsortedResults := SortedCollection sortBlock: [:c1 :c2 | c1 \t\t\tf1score >= c2 f1score].\r\t\t\tcorrectOutput:= (visitor visit: (correctlyParsedInputs at: \t\t\tindex)) output.\r\t\t\tself halt.\t\t\t\r\t\t\tallResults := (((ValidatorSuite new)\r\t\t\t\tcorrectResult: correctOutput;\r\t\t\t\tresults: (parsedInputs at: index);\r\t\t\t\tyourself) validate).\r\t\t\t\t\r\t\t\t\tallResults do: [ :result | (result isKindOf: ResultNode) & \t\t\t\t\t(result f1score isKindOf: Float)\r\t\t\t\t\tifTrue:[sortedResults add: result]].\r\t\t\t\t\r\t\t\t\tfinalResults add: (sortedResults at:1).\r\t\t\t\r\t\t ].\r\t^finalResults',			#stamp : 'MathiasFuchs 12/31/2016 15:13',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T15:26:35.73045+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '33' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '34' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #SetValidator,				#isMetaSide : false			},			#name : #'validate:correctParser:',			#protocol : #'as yet unclassified',			#sourceCode : 'validate: aCollection correctParser: correctParser\r\t|parsedInputs correctlyParsedInputs finalResults|\r\t\r\t\r\tparsedInputs:=  ParserGenerator parseSetWithOrder: aCollection.\r\tcorrectlyParsedInputs:= OrderedCollection new.\r\tfinalResults:= OrderedCollection new.\r\t\r\t\"get the correct parsed String\"\r\t(aCollection do: [ :string |\r\t\tcorrectlyParsedInputs add:(correctParser parse:string)\t ]).\r\t\r\r\t(1 to: parsedInputs size) do: [ :index |\r\t\t|visitor correctOutput allResults sortedResults|\r\t\t\tvisitor:= ExportVisitor new. \r\t\t\tsortedResults := SortedCollection sortBlock: [:c1 :c2 | c1 \t\t\tf1score >= c2 f1score].\r\t\t\tcorrectOutput:= (visitor visit: (correctlyParsedInputs at: \t\t\tindex)) output.\r\t\t\tself halt.\t\t\t\r\t\t\tallResults := (((ValidatorSuite new)\r\t\t\t\tcorrectResult: correctOutput;\r\t\t\t\tresults: (parsedInputs at: index);\r\t\t\t\tyourself) validate).\r\t\t\t\t\r\t\t\t\tallResults do: [ :result | (result isKindOf: ResultNode) & \t\t\t\t\t(result f1score isKindOf: Float)\r\t\t\t\t\tifTrue:[sortedResults add: result]].\r\t\t\t\t\r\t\t\t\tfinalResults add: (sortedResults at:1).\r\t\t\t\r\t\t ].\r\t^finalResults',			#stamp : 'MathiasFuchs 12/31/2016 15:13',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #SetValidator,				#isMetaSide : false			},			#name : #'validate:correctParser:',			#protocol : #'as yet unclassified',			#sourceCode : 'validate: aCollection correctParser: correctParser\r\t|parsedInputs correctlyParsedInputs finalResults|\r\t\r\t\r\tparsedInputs:=  ParserGenerator parseSetWithOrder: aCollection.\r\tcorrectlyParsedInputs:= OrderedCollection new.\r\tfinalResults:= OrderedCollection new.\r\t\r\t\"get the correct parsed String\"\r\t(aCollection do: [ :string |\r\t\tcorrectlyParsedInputs add:(correctParser parse:string)\t ]).\r\t\r\r\t(1 to: parsedInputs size) do: [ :index |\r\t\t|visitor correctOutput allResults sortedResults|\r\t\t\tvisitor:= ExportVisitor new. \r\t\t\tsortedResults := SortedCollection sortBlock: [:c1 :c2 | c1 \t\t\tf1score >= c2 f1score].\r\t\t\tcorrectOutput:= (visitor visit: (correctlyParsedInputs at: \t\t\tindex)) output.\t\t\r\t\t\tallResults := (((ValidatorSuite new)\r\t\t\t\tcorrectResult: correctOutput;\r\t\t\t\tresults: (parsedInputs at: index);\r\t\t\t\tyourself) validate).\r\t\t\t\t\tself halt.\t\r\t\t\t\tallResults do: [ :result | (result isKindOf: ResultNode) & (result f1score isKindOf: \t\t\t\tFloat)\r\t\t\t\tifTrue:[sortedResults add: result]].\r\t\t\t\t\r\t\t\t\tfinalResults add: (sortedResults at:1).\r\t\t\t\r\t\t ].\r\t^finalResults',			#stamp : 'MathiasFuchs 12/31/2016 15:26',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T15:28:40.22745+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '34' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '35' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #SetValidator,				#isMetaSide : false			},			#name : #'validate:correctParser:',			#protocol : #'as yet unclassified',			#sourceCode : 'validate: aCollection correctParser: correctParser\r\t|parsedInputs correctlyParsedInputs finalResults|\r\t\r\t\r\tparsedInputs:=  ParserGenerator parseSetWithOrder: aCollection.\r\tcorrectlyParsedInputs:= OrderedCollection new.\r\tfinalResults:= OrderedCollection new.\r\t\r\t\"get the correct parsed String\"\r\t(aCollection do: [ :string |\r\t\tcorrectlyParsedInputs add:(correctParser parse:string)\t ]).\r\t\r\r\t(1 to: parsedInputs size) do: [ :index |\r\t\t|visitor correctOutput allResults sortedResults|\r\t\t\tvisitor:= ExportVisitor new. \r\t\t\tsortedResults := SortedCollection sortBlock: [:c1 :c2 | c1 \t\t\tf1score >= c2 f1score].\r\t\t\tcorrectOutput:= (visitor visit: (correctlyParsedInputs at: \t\t\tindex)) output.\t\t\r\t\t\tallResults := (((ValidatorSuite new)\r\t\t\t\tcorrectResult: correctOutput;\r\t\t\t\tresults: (parsedInputs at: index);\r\t\t\t\tyourself) validate).\r\t\t\t\t\tself halt.\t\r\t\t\t\tallResults do: [ :result | (result isKindOf: ResultNode) & (result f1score isKindOf: \t\t\t\tFloat)\r\t\t\t\tifTrue:[sortedResults add: result]].\r\t\t\t\t\r\t\t\t\tfinalResults add: (sortedResults at:1).\r\t\t\t\r\t\t ].\r\t^finalResults',			#stamp : 'MathiasFuchs 12/31/2016 15:26',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #SetValidator,				#isMetaSide : false			},			#name : #'validate:correctParser:',			#protocol : #'as yet unclassified',			#sourceCode : 'validate: aCollection correctParser: correctParser\r\t|parsedInputs correctlyParsedInputs finalResults|\r\t\r\t\r\tparsedInputs:=  ParserGenerator parseSetWithOrder: aCollection.\r\tcorrectlyParsedInputs:= OrderedCollection new.\r\tfinalResults:= OrderedCollection new.\r\t\r\t\"get the correct parsed String\"\r\t(aCollection do: [ :string |\r\t\tcorrectlyParsedInputs add:(correctParser parse:string)\t ]).\r\t\r\r\t(1 to: parsedInputs size) do: [ :index |\r\t\t|visitor correctOutput allResults sortedResults|\r\t\t\tvisitor:= ExportVisitor new. \r\t\t\tsortedResults := SortedCollection sortBlock: [:c1 :c2 | c1 \t\t\tf1score >= c2 f1score].\r\t\t\tcorrectOutput:= (visitor visit: (correctlyParsedInputs at: \t\t\tindex)) output.\t\t\r\t\t\tallResults := (((ValidatorSuite new)\r\t\t\t\tcorrectResult: correctOutput;\r\t\t\t\tresults: (parsedInputs at: index);\r\t\t\t\tyourself) validate).\r\t\t\t\t\tself halt.\t\r\t\t\t\tallResults do: [ :result | (result isKindOf: ResultNode) & (result f1score isKindOf: \t\t\t\tFloat)\r\t\t\t\tifTrue:[sortedResults add: result]].\r\t\t\t\t\r\t\t\t\t(sortedResults size >0)\r\t\t\t\tifTrue:[\r\t\t\t\t\tfinalResults add: (sortedResults at:1)]\r\t\t\t\tifFalse:[finalResults add:(allResults at:1)].\r\t\t\t\r\t\t ].\r\t^finalResults',			#stamp : 'MathiasFuchs 12/31/2016 15:28',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T15:30:01.42745+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '35' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '36' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #SetValidator,				#isMetaSide : false			},			#name : #'validate:correctParser:',			#protocol : #'as yet unclassified',			#sourceCode : 'validate: aCollection correctParser: correctParser\r\t|parsedInputs correctlyParsedInputs finalResults|\r\t\r\t\r\tparsedInputs:=  ParserGenerator parseSetWithOrder: aCollection.\r\tcorrectlyParsedInputs:= OrderedCollection new.\r\tfinalResults:= OrderedCollection new.\r\t\r\t\"get the correct parsed String\"\r\t(aCollection do: [ :string |\r\t\tcorrectlyParsedInputs add:(correctParser parse:string)\t ]).\r\t\r\r\t(1 to: parsedInputs size) do: [ :index |\r\t\t|visitor correctOutput allResults sortedResults|\r\t\t\tvisitor:= ExportVisitor new. \r\t\t\tsortedResults := SortedCollection sortBlock: [:c1 :c2 | c1 \t\t\tf1score >= c2 f1score].\r\t\t\tcorrectOutput:= (visitor visit: (correctlyParsedInputs at: \t\t\tindex)) output.\t\t\r\t\t\tallResults := (((ValidatorSuite new)\r\t\t\t\tcorrectResult: correctOutput;\r\t\t\t\tresults: (parsedInputs at: index);\r\t\t\t\tyourself) validate).\r\t\t\t\t\tself halt.\t\r\t\t\t\tallResults do: [ :result | (result isKindOf: ResultNode) & (result f1score isKindOf: \t\t\t\tFloat)\r\t\t\t\tifTrue:[sortedResults add: result]].\r\t\t\t\t\r\t\t\t\t(sortedResults size >0)\r\t\t\t\tifTrue:[\r\t\t\t\t\tfinalResults add: (sortedResults at:1)]\r\t\t\t\tifFalse:[finalResults add:(allResults at:1)].\r\t\t\t\r\t\t ].\r\t^finalResults',			#stamp : 'MathiasFuchs 12/31/2016 15:28',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #SetValidator,				#isMetaSide : false			},			#name : #'validate:correctParser:',			#protocol : #'as yet unclassified',			#sourceCode : 'validate: aCollection correctParser: correctParser\r\t|parsedInputs correctlyParsedInputs finalResults|\r\t\r\t\r\tparsedInputs:=  ParserGenerator parseSetWithOrder: aCollection.\r\tcorrectlyParsedInputs:= OrderedCollection new.\r\tfinalResults:= OrderedCollection new.\r\t\r\t\"get the correct parsed String\"\r\t(aCollection do: [ :string |\r\t\tcorrectlyParsedInputs add:(correctParser parse:string)\t ]).\r\t\r\r\t(1 to: parsedInputs size) do: [ :index |\r\t\t|visitor correctOutput allResults sortedResults|\r\t\t\tvisitor:= ExportVisitor new. \r\t\t\tsortedResults := SortedCollection sortBlock: [:c1 :c2 | c1 \t\t\tf1score >= c2 f1score].\r\t\t\tcorrectOutput:= (visitor visit: (correctlyParsedInputs at: \t\t\tindex)) output.\t\t\r\t\t\tallResults := (((ValidatorSuite new)\r\t\t\t\tcorrectResult: correctOutput;\r\t\t\t\tresults: (parsedInputs at: index);\r\t\t\t\tyourself) validate).\r\t\t\t\tallResults do: [ :result | (result isKindOf: ResultNode) & (result f1score isKindOf: \t\t\t\tFloat)\r\t\t\t\tifTrue:[sortedResults add: result]].\r\t\t\t\t\r\t\t\t\t(sortedResults size >0)\r\t\t\t\tifTrue:[\r\t\t\t\t\tfinalResults add: (sortedResults at:1)]\r\t\t\t\tifFalse:[finalResults add:(allResults at:1)].\r\t\t\t\r\t\t ].\r\t^finalResults',			#stamp : 'MathiasFuchs 12/31/2016 15:30',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T15:30:16.09145+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '36' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '37' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults solutionsOfFirst|\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\tsolutionsOfFirst:= OrderedCollection new.\r\t\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\tparsers do: [ :parser |\r\t\t|res|\r\t\tres:= [parser parse:(aSet first)] valueWithin:150 milliSeconds onTimeout: (#failure).\r\t\tsolutionsOfFirst add:res ].\r\t\r\tsolutionsOfFirst removeAllSuchThat: [ :elt |\r\t\t(elt isKindOf: Node) not ].\r\t\"sort them\"\r\t (solutionsOfFirst sorted: [ :eltA :eltB | (eltA allChildrenWeight > eltB allChildrenWeight)]).\r\t\r\t(solutionsOfFirst size >50)\r\tifTrue: [\tsolutionsOfFirst:= solutionsOfFirst first:50  ].\r\r\t\r\t\"recreate the parsers which are needed\"\r\tparsers:= OrderedCollection new.\r\tsolutionsOfFirst do: [ :elt |\r\t\tparsers add: (elt parserFactory generateParser) ].\r\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 15:05',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults solutionsOfFirst|\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\tsolutionsOfFirst:= OrderedCollection new.\r\t\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\tself halt.\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\tparsers do: [ :parser |\r\t\t|res|\r\t\tres:= [parser parse:(aSet first)] valueWithin:150 milliSeconds onTimeout: (#failure).\r\t\tsolutionsOfFirst add:res ].\r\t\r\tsolutionsOfFirst removeAllSuchThat: [ :elt |\r\t\t(elt isKindOf: Node) not ].\r\t\"sort them\"\r\t (solutionsOfFirst sorted: [ :eltA :eltB | (eltA allChildrenWeight > eltB allChildrenWeight)]).\r\t\r\t(solutionsOfFirst size >50)\r\tifTrue: [\tsolutionsOfFirst:= solutionsOfFirst first:50  ].\r\r\t\r\t\"recreate the parsers which are needed\"\r\tparsers:= OrderedCollection new.\r\tsolutionsOfFirst do: [ :elt |\r\t\tparsers add: (elt parserFactory generateParser) ].\r\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 15:30',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T15:43:30.74245+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '37' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '38' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #BruteForceTagOfTagsGenerator,				#isMetaSide : false			},			#name : #generate,			#protocol : #accessing,			#sourceCode : 'generate\r\t^(self productionNamed: #stringOrTag )generate\r\t\tcollect: [ :e | e nonEmpty star ].\r\t\t',			#stamp : 'Icewater 12/31/2016 11:48:14',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #BruteForceTagOfTagsGenerator,				#isMetaSide : false			},			#name : #generate,			#protocol : #accessing,			#sourceCode : 'generate\r\t^(self productionNamed: #stringOrTag )generate\r\t\tcollect: [ :e | self halt.e nonEmpty star ].\r\t\t',			#stamp : 'MathiasFuchs 12/31/2016 15:43',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T15:45:28.26545+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '38' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '39' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #BruteForceTagOfTagsGenerator,				#isMetaSide : false			},			#name : #'actionOn:',			#protocol : #accessing,			#sourceCode : 'actionOn: parser\r\t^ parser ==> [ :e | \r\t\t(RawText new)\r\t\t\tcontents: e second inputValue;\r\t\t\tparserFactory: self;\r\t\t\tyourself\r\t]',			#stamp : 'MathiasFuchs 12/31/2016 15:45',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T15:46:03.52045+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '39' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '40' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #BruteForceTagOfTagsGenerator,				#isMetaSide : false			},			#name : #'actionOn:',			#protocol : #accessing,			#sourceCode : 'actionOn: parser\r\t^ parser ==> [ :e | \r\t\t(RawText new)\r\t\t\tcontents: e second inputValue;\r\t\t\tparserFactory: self;\r\t\t\tyourself\r\t]',			#stamp : 'MathiasFuchs 12/31/2016 15:45',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T15:46:36.56645+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '40' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '41' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #BruteForceTagOfTagsGenerator,				#isMetaSide : false			},			#name : #generate,			#protocol : #accessing,			#sourceCode : 'generate\r\t^(self productionNamed: #stringOrTag )generate\r\t\tcollect: [ :e | self halt.e nonEmpty star ].\r\t\t',			#stamp : 'MathiasFuchs 12/31/2016 15:43',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #BruteForceTagOfTagsGenerator,				#isMetaSide : false			},			#name : #generate,			#protocol : #accessing,			#sourceCode : 'generate\r\t^(self productionNamed: #stringOrTag )generate\r\t\tcollect: [ :e | e nonEmpty star ].\r\t\t',			#stamp : 'MathiasFuchs 12/31/2016 15:46',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T15:53:25.93345+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '41' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '42' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults solutionsOfFirst|\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\tsolutionsOfFirst:= OrderedCollection new.\r\t\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\tself halt.\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\tparsers do: [ :parser |\r\t\t|res|\r\t\tres:= [parser parse:(aSet first)] valueWithin:150 milliSeconds onTimeout: (#failure).\r\t\tsolutionsOfFirst add:res ].\r\t\r\tsolutionsOfFirst removeAllSuchThat: [ :elt |\r\t\t(elt isKindOf: Node) not ].\r\t\"sort them\"\r\t (solutionsOfFirst sorted: [ :eltA :eltB | (eltA allChildrenWeight > eltB allChildrenWeight)]).\r\t\r\t(solutionsOfFirst size >50)\r\tifTrue: [\tsolutionsOfFirst:= solutionsOfFirst first:50  ].\r\r\t\r\t\"recreate the parsers which are needed\"\r\tparsers:= OrderedCollection new.\r\tsolutionsOfFirst do: [ :elt |\r\t\tparsers add: (elt parserFactory generateParser) ].\r\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 15:30',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults solutionsOfFirst solutionsOfFirstElts|\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\tsolutionsOfFirst:= OrderedCollection new.\r\tsolutionsOfFirstElts:= OrderedCollection new.\r\t\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\tparsers do: [ :parser |\r\t\t|res|\r\t\tres:= [parser parse:(aSet first)] valueWithin:150 milliSeconds onTimeout: (#failure).\r\t\tsolutionsOfFirst add:res ].\r\t\r\tsolutionsOfFirst removeAllSuchThat: [ :elt |\r\t\t(elt isPetitFailure) ].\r\t\"elementarize the elements, if you get returned a list of elements ( because of non empty star) have to make better:S\"\r\tsolutionsOfFirst do: [ :elt |\r\t\t(elt isKindOf: OrderedCollection) \r\t\tifTrue:[solutionsOfFirstElts add:((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: elt;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)\r\t\t\t]\r\t\tifFalse:[solutionsOfFirstElts add: elt].\r\t\t ].\r\t\r\tsolutionsOfFirstElts removeAllSuchThat: [ :elt |\r\t\t(elt isKindOf: Node)not ].\r\t\"sort them\"\r\t (solutionsOfFirst sorted: [ :eltA :eltB | (eltA allChildrenWeight > eltB allChildrenWeight)]).\r\t\r\t(solutionsOfFirst size >50)\r\tifTrue: [\tsolutionsOfFirst:= solutionsOfFirst first:50  ].\r\r\t\r\t\"recreate the parsers which are needed\"\r\tparsers:= OrderedCollection new.\r\tsolutionsOfFirst do: [ :elt |\r\t\tparsers add: (elt parserFactory generateParser) ].\r\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 15:53',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T15:53:40.32245+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '42' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '43' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults solutionsOfFirst solutionsOfFirstElts|\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\tsolutionsOfFirst:= OrderedCollection new.\r\tsolutionsOfFirstElts:= OrderedCollection new.\r\t\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\tparsers do: [ :parser |\r\t\t|res|\r\t\tres:= [parser parse:(aSet first)] valueWithin:150 milliSeconds onTimeout: (#failure).\r\t\tsolutionsOfFirst add:res ].\r\t\r\tsolutionsOfFirst removeAllSuchThat: [ :elt |\r\t\t(elt isPetitFailure) ].\r\t\"elementarize the elements, if you get returned a list of elements ( because of non empty star) have to make better:S\"\r\tsolutionsOfFirst do: [ :elt |\r\t\t(elt isKindOf: OrderedCollection) \r\t\tifTrue:[solutionsOfFirstElts add:((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: elt;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)\r\t\t\t]\r\t\tifFalse:[solutionsOfFirstElts add: elt].\r\t\t ].\r\t\r\tsolutionsOfFirstElts removeAllSuchThat: [ :elt |\r\t\t(elt isKindOf: Node)not ].\r\t\"sort them\"\r\t (solutionsOfFirst sorted: [ :eltA :eltB | (eltA allChildrenWeight > eltB allChildrenWeight)]).\r\t\r\t(solutionsOfFirst size >50)\r\tifTrue: [\tsolutionsOfFirst:= solutionsOfFirst first:50  ].\r\r\t\r\t\"recreate the parsers which are needed\"\r\tparsers:= OrderedCollection new.\r\tsolutionsOfFirst do: [ :elt |\r\t\tparsers add: (elt parserFactory generateParser) ].\r\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 15:53',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults solutionsOfFirst solutionsOfFirstElts|\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\tsolutionsOfFirst:= OrderedCollection new.\r\tsolutionsOfFirstElts:= OrderedCollection new.\r\t\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\tparsers do: [ :parser |\r\t\t|res|\r\t\tres:= [parser parse:(aSet first)] valueWithin:150 milliSeconds onTimeout: (#failure).\r\t\tsolutionsOfFirst add:res ].\r\t\r\tself halt.\r\t\r\tsolutionsOfFirst removeAllSuchThat: [ :elt |\r\t\t(elt isPetitFailure) ].\r\t\"elementarize the elements, if you get returned a list of elements ( because of non empty star) have to make better:S\"\r\tsolutionsOfFirst do: [ :elt |\r\t\t(elt isKindOf: OrderedCollection) \r\t\tifTrue:[solutionsOfFirstElts add:((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: elt;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)\r\t\t\t]\r\t\tifFalse:[solutionsOfFirstElts add: elt].\r\t\t ].\r\t\r\tsolutionsOfFirstElts removeAllSuchThat: [ :elt |\r\t\t(elt isKindOf: Node)not ].\r\t\"sort them\"\r\t (solutionsOfFirst sorted: [ :eltA :eltB | (eltA allChildrenWeight > eltB allChildrenWeight)]).\r\t\r\t(solutionsOfFirst size >50)\r\tifTrue: [\tsolutionsOfFirst:= solutionsOfFirst first:50  ].\r\r\t\r\t\"recreate the parsers which are needed\"\r\tparsers:= OrderedCollection new.\r\tsolutionsOfFirst do: [ :elt |\r\t\tparsers add: (elt parserFactory generateParser) ].\r\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 15:53',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T15:54:54.58345+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '43' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '44' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults solutionsOfFirst solutionsOfFirstElts|\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\tsolutionsOfFirst:= OrderedCollection new.\r\tsolutionsOfFirstElts:= OrderedCollection new.\r\t\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\tparsers do: [ :parser |\r\t\t|res|\r\t\tres:= [parser parse:(aSet first)] valueWithin:150 milliSeconds onTimeout: (#failure).\r\t\tsolutionsOfFirst add:res ].\r\t\r\tself halt.\r\t\r\tsolutionsOfFirst removeAllSuchThat: [ :elt |\r\t\t(elt isPetitFailure) ].\r\t\"elementarize the elements, if you get returned a list of elements ( because of non empty star) have to make better:S\"\r\tsolutionsOfFirst do: [ :elt |\r\t\t(elt isKindOf: OrderedCollection) \r\t\tifTrue:[solutionsOfFirstElts add:((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: elt;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)\r\t\t\t]\r\t\tifFalse:[solutionsOfFirstElts add: elt].\r\t\t ].\r\t\r\tsolutionsOfFirstElts removeAllSuchThat: [ :elt |\r\t\t(elt isKindOf: Node)not ].\r\t\"sort them\"\r\t (solutionsOfFirst sorted: [ :eltA :eltB | (eltA allChildrenWeight > eltB allChildrenWeight)]).\r\t\r\t(solutionsOfFirst size >50)\r\tifTrue: [\tsolutionsOfFirst:= solutionsOfFirst first:50  ].\r\r\t\r\t\"recreate the parsers which are needed\"\r\tparsers:= OrderedCollection new.\r\tsolutionsOfFirst do: [ :elt |\r\t\tparsers add: (elt parserFactory generateParser) ].\r\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 15:53',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults solutionsOfFirst solutionsOfFirstElts|\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\tsolutionsOfFirst:= OrderedCollection new.\r\tsolutionsOfFirstElts:= OrderedCollection new.\r\t\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\tparsers do: [ :parser |\r\t\t|res|\r\t\tres:= [parser parse:(aSet first)] valueWithin:150 milliSeconds onTimeout: (#failure).\r\t\tsolutionsOfFirst add:res ].\r\t\r\tself halt.\r\t\r\tsolutionsOfFirst removeAllSuchThat: [ :elt |\r\t\t(elt isPetitFailure) ].\r\t\"elementarize the elements, if you get returned a list of elements ( because of non empty star) have to make better:S\"\r\tsolutionsOfFirst do: [ :elt |\r\t\tself halt.\r\t\t(elt isKindOf: OrderedCollection) \r\t\tifTrue:[solutionsOfFirstElts add:((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: elt;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)\r\t\t\t]\r\t\tifFalse:[solutionsOfFirstElts add: elt].\r\t\t ].\r\t\r\tsolutionsOfFirstElts removeAllSuchThat: [ :elt |\r\t\t(elt isKindOf: Node)not ].\r\t\"sort them\"\r\t (solutionsOfFirst sorted: [ :eltA :eltB | (eltA allChildrenWeight > eltB allChildrenWeight)]).\r\t\r\t(solutionsOfFirst size >50)\r\tifTrue: [\tsolutionsOfFirst:= solutionsOfFirst first:50  ].\r\r\t\r\t\"recreate the parsers which are needed\"\r\tparsers:= OrderedCollection new.\r\tsolutionsOfFirst do: [ :elt |\r\t\tparsers add: (elt parserFactory generateParser) ].\r\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 15:54',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T15:56:31.38045+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '44' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '45' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults solutionsOfFirst solutionsOfFirstElts|\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\tsolutionsOfFirst:= OrderedCollection new.\r\tsolutionsOfFirstElts:= OrderedCollection new.\r\t\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\tparsers do: [ :parser |\r\t\t|res|\r\t\tres:= [parser parse:(aSet first)] valueWithin:150 milliSeconds onTimeout: (#failure).\r\t\tsolutionsOfFirst add:res ].\r\t\r\tself halt.\r\t\r\tsolutionsOfFirst removeAllSuchThat: [ :elt |\r\t\t(elt isPetitFailure) ].\r\t\"elementarize the elements, if you get returned a list of elements ( because of non empty star) have to make better:S\"\r\tsolutionsOfFirst do: [ :elt |\r\t\tself halt.\r\t\t(elt isKindOf: OrderedCollection) \r\t\tifTrue:[solutionsOfFirstElts add:((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: elt;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)\r\t\t\t]\r\t\tifFalse:[solutionsOfFirstElts add: elt].\r\t\t ].\r\t\r\tsolutionsOfFirstElts removeAllSuchThat: [ :elt |\r\t\t(elt isKindOf: Node)not ].\r\t\"sort them\"\r\t (solutionsOfFirst sorted: [ :eltA :eltB | (eltA allChildrenWeight > eltB allChildrenWeight)]).\r\t\r\t(solutionsOfFirst size >50)\r\tifTrue: [\tsolutionsOfFirst:= solutionsOfFirst first:50  ].\r\r\t\r\t\"recreate the parsers which are needed\"\r\tparsers:= OrderedCollection new.\r\tsolutionsOfFirst do: [ :elt |\r\t\tparsers add: (elt parserFactory generateParser) ].\r\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 15:54',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults solutionsOfFirst solutionsOfFirstElts|\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\tsolutionsOfFirst:= OrderedCollection new.\r\tsolutionsOfFirstElts:= OrderedCollection new.\r\t\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\tparsers do: [ :parser |\r\t\t|res|\r\t\tres:= [parser parse:(aSet first)] valueWithin:150 milliSeconds onTimeout: (#failure).\r\t\tsolutionsOfFirst add:res ].\r\t\r\tself halt.\r\t\r\tsolutionsOfFirst removeAllSuchThat: [ :elt |\r\t\t(elt isPetitFailure) ].\r\t\"elementarize the elements, if you get returned a list of elements ( because of non empty star) have to make better:S\"\r\tsolutionsOfFirst do: [ :elt |\r\t\tself halt.\r\t\t(elt isKindOf: Array) \r\t\tifTrue:[solutionsOfFirstElts add:((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: elt;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)\r\t\t\t]\r\t\tifFalse:[solutionsOfFirstElts add: elt].\r\t\t ].\r\t\r\tsolutionsOfFirstElts removeAllSuchThat: [ :elt |\r\t\t(elt isKindOf: Node)not ].\r\t\"sort them\"\r\t (solutionsOfFirst sorted: [ :eltA :eltB | (eltA allChildrenWeight > eltB allChildrenWeight)]).\r\t\r\t(solutionsOfFirst size >50)\r\tifTrue: [\tsolutionsOfFirst:= solutionsOfFirst first:50  ].\r\r\t\r\t\"recreate the parsers which are needed\"\r\tparsers:= OrderedCollection new.\r\tsolutionsOfFirst do: [ :elt |\r\t\tparsers add: (elt parserFactory generateParser) ].\r\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 15:56',			#package : #RecognisingStructuralPatterns		}	}}OmEntry {	#tags : {		#author : 'MathiasFuchs',		#time : DateAndTime [ '2016-12-31T15:56:48.25845+01:00' ],		#prior : OmReference [ 'workingImgSilv_az3w6xs', '45' ],		#self : OmReference [ 'workingImgSilv_az3w6xs', '46' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults solutionsOfFirst solutionsOfFirstElts|\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\tsolutionsOfFirst:= OrderedCollection new.\r\tsolutionsOfFirstElts:= OrderedCollection new.\r\t\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\tparsers do: [ :parser |\r\t\t|res|\r\t\tres:= [parser parse:(aSet first)] valueWithin:150 milliSeconds onTimeout: (#failure).\r\t\tsolutionsOfFirst add:res ].\r\t\r\tself halt.\r\t\r\tsolutionsOfFirst removeAllSuchThat: [ :elt |\r\t\t(elt isPetitFailure) ].\r\t\"elementarize the elements, if you get returned a list of elements ( because of non empty star) have to make better:S\"\r\tsolutionsOfFirst do: [ :elt |\r\t\tself halt.\r\t\t(elt isKindOf: Array) \r\t\tifTrue:[solutionsOfFirstElts add:((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: elt;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)\r\t\t\t]\r\t\tifFalse:[solutionsOfFirstElts add: elt].\r\t\t ].\r\t\r\tsolutionsOfFirstElts removeAllSuchThat: [ :elt |\r\t\t(elt isKindOf: Node)not ].\r\t\"sort them\"\r\t (solutionsOfFirst sorted: [ :eltA :eltB | (eltA allChildrenWeight > eltB allChildrenWeight)]).\r\t\r\t(solutionsOfFirst size >50)\r\tifTrue: [\tsolutionsOfFirst:= solutionsOfFirst first:50  ].\r\r\t\r\t\"recreate the parsers which are needed\"\r\tparsers:= OrderedCollection new.\r\tsolutionsOfFirst do: [ :elt |\r\t\tparsers add: (elt parserFactory generateParser) ].\r\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 15:56',			#package : #RecognisingStructuralPatterns		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ParserGenerator class',				#isMetaSide : true			},			#name : #'parseSetWithOrder:',			#protocol : #parsing,			#sourceCode : 'parseSetWithOrder: aSet\t\r\t|parsers generators subResults results finalSubResults solutionsOfFirst solutionsOfFirstElts|\r\t\"assertion to make sure first is short\"\r\tself assert: ((aSet at:1) size <= 250).\r\tresults:= OrderedCollection new.\r\tsubResults:= OrderedCollection new.\r\tsolutionsOfFirst:= OrderedCollection new.\r\tsolutionsOfFirstElts:= OrderedCollection new.\r\t\t\t\r\t\"build parsers from the first element of the set, which is supposed to be the shortest. Then reuse them\"\r\tgenerators:= self getBruteForceGeneratorSubclasses.\r\tparsers:= OrderedCollection new.\r\t\r\tgenerators do:[:gen | parsers addAll: (gen getParsers: aSet first)].\r\t\r\tparsers do: [ :parser |\r\t\t|res|\r\t\tres:= [parser parse:(aSet first)] valueWithin:150 milliSeconds onTimeout: (#failure).\r\t\tsolutionsOfFirst add:res ].\r\t\r\t\r\tsolutionsOfFirst removeAllSuchThat: [ :elt |\r\t\t(elt isPetitFailure) ].\r\t\"elementarize the elements, if you get returned a list of elements ( because of non empty star) have to make better:S\"\r\tsolutionsOfFirst do: [ :elt |\r\t\t(elt isKindOf: Array) \r\t\tifTrue:[solutionsOfFirstElts add:((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: elt;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)\r\t\t\t]\r\t\tifFalse:[solutionsOfFirstElts add: elt].\r\t\t ].\r\t\r\t\tself halt.\r\tsolutionsOfFirstElts removeAllSuchThat: [ :elt |\r\t\t(elt isKindOf: Node)not ].\r\t\"sort them\"\r\t (solutionsOfFirst sorted: [ :eltA :eltB | (eltA allChildrenWeight > eltB allChildrenWeight)]).\r\t\r\t(solutionsOfFirst size >50)\r\tifTrue: [\tsolutionsOfFirst:= solutionsOfFirst first:50  ].\r\r\t\r\t\"recreate the parsers which are needed\"\r\tparsers:= OrderedCollection new.\r\tsolutionsOfFirst do: [ :elt |\r\t\tparsers add: (elt parserFactory generateParser) ].\r\r\t\t\t\t\t\t\r\t\"now proceed as usual, take the whole set and parse stuff with the remaining parsers\"\r\taSet do: [ :elt |\r\t\tsubResults:= OrderedCollection new.\r\t\tfinalSubResults:= OrderedCollection new.\r\t\tparsers do: [ :parser |\r\t\t\tsubResults add:([ (parser parse:elt)\t\t ] valueWithin: 2000 milliSeconds onTimeout:#failure).  \t\t].\t\r\t\t\t\t\t\t\t\r\t\t\tsubResults do: [ :res |\r\t\t\t\t(res isKindOf: Collection) &(res asString= \'failure\') not\r\t\t\t\tifTrue:[\r\t\t\t\t\t(res size >1) \r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tfinalSubResults add:\r\t\t\t\t\t\t((Element new)\r\t\t\t\t\t\t\tname:\'__ROOT__\';\r\t\t\t\t\t\t\tchildren: res;\r\t\t\t\t\t\t\tweight:0;\r\t\t\t\t\t\t\tyourself)]\r\t\t\t\t\t\tifFalse:[finalSubResults add: res first]]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t(res isKindOf: Node)\r\t\t\t\t\t\t\tifTrue:[finalSubResults add:(res) ].]\r\r\t\t\t\t].\r\r\t\t\r\t\tresults add: finalSubResults.\t\t\t\t\r\t\t\t\t\t\t\t].\r\t\t\t\r\t\t^results',			#stamp : 'MathiasFuchs 12/31/2016 15:56',			#package : #RecognisingStructuralPatterns		}	}}